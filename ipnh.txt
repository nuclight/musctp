   !!! very early raw draft!

      IPnh: Internet Protocol's Next Hop / Network Hierarchy
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The muSCTP protocol is mostly agnostic to underlying network layer
   protocol, so this, assuming muSCTP is significantly deployed, allows
   for changing to another IP version, not only IPv4 or IPv6 - something very
   hard to do on traditional TCP/UDP which essentially hardcode suport if
   either of two present versions.

1. Introduction.

TBD incorporate Section 1 of https://www.ietf.org/archive/id/draft-omar-ipv10-12.txt

   There is still need for newer version of IP protocol - IPv6 is not
   satisfactory. IPv6 problems are real and remain real, see for example
   Huawei's NewIP initiative.

   IPv6, being a classic example of second-system effect (see F. Brooks'
   "The Mythical Man-Month" book), in fact is an epic fail. On the time line
   where entire Internet issued a new version if ubiquitous protocol, deployed
   it and then disabled interoperation with old unsupporting clients, this
   happened e.g. 4 times for SSL/TLS - but for the same quarter of century
   IPv6 has failed to be deployed as just only one main version.

   IPv6 has almost no benefits, just flaws. In fact, the only benefits are:

   * easy autoconfiguration in some cases
   * larger address space.

   And the latter is in fact not benefit, as *EVERY* successor of IPv4 had to
   have larger address space, IPv6 was just one candidate at IPng contest.

   The biggest problem of IPv6 remains backwards compatibility - old IPv4 with
   unmodified software cannot *transparently* speak to IPv6 hosts (NAT64
   finally appearedm, but too late and solving just half of two directions).

   The next big problem of IPv6 is Internet-of-Things (IoT) and mobile hosts.
   Ironically, larger address space was intended just for these myriads of
   devices, and yet it failed in practice - because of 1) fragmentation and 2)
   larger header. See how - the quote from RFC 4944: 

   | The MTU size for IPv6 packets over IEEE 802.15.4 is 1280 octets.
   | However, a full IPv6 packet does not fit in an IEEE 802.15.4 frame.
   | 802.15.4 protocol data units have different sizes depending on how
   | much overhead is present [ieee802.15.4].  Starting from a maximum
   | physical layer packet size of 127 octets (aMaxPHYPacketSize) and a
   | maximum frame overhead of 25 (aMaxFrameOverhead), the resultant
   | maximum frame size at the media access control layer is 102 octets.
   | Link-layer security imposes further overhead, which in the maximum
   | case (21 octets of overhead in the AES-CCM-128 case, versus 9 and 13
   | for AES-CCM-32 and AES-CCM-64, respectively) leaves only 81 octets
   | available.  This is obviously far below the minimum IPv6 packet size
   | of 1280 octets, and in keeping with Section 5 of the IPv6
   | specification [RFC2460], a fragmention and reassembly adaptation
   | layer must be provided at the layer below IP.  Such a layer is
   | defined below in Section 5.
   |
   | Furthermore, since the IPv6 header is 40 octets long, this leaves
   | only 41 octets for upper-layer protocols, like UDP.  The latter uses
   | 8 octets in the header which leaves only 33 octets for application
   | data.  Additionally, as pointed out above, there is a need for a
   | fragmentation and reassembly layer, which will use even more octets.

   So, 6LoWPAN defines an ugly set of crutches for IPv6 on it - not surprising
   that ZigBee (on same 802.15.4) is more successful.

   And IPv6 is very bad at fragmentation - gateway to constrained segment
   cannot just fragment packet, as it must behave like DF bit is always set...
   Moreover, as NDN Fragmentation Memo states, de-facto bad fragmentation
   support leads to "ossification" of IP packet size to common 1500 byte MTU,
   while for future high-speed links it may be desirable to raise MTU for both
   performance reasons and sequence number space limits shifting from byte
   numbers to packet numbers.

   Mobility is also not achieved - see https://apenwarr.ca/log/20170810 for
   long discussion of mobility evolution, and that IPv6 Host Mobility suffers
   from fundamental problem: latency, because of tunneling. The proposal on
   that page for UUID-like sockets is somewhat too radical, however - while
   muSCTP uses the same principle in Connection Tag, this could require
   replacing all transport protocols to muSCTP instead of gradual transition.
   So supporting older protocols by splitting single long identifier to host
   part and L4 part may still be reasonable.

   There are also other IPv6 problems, https://netch.livejournal.com/8262.html
   may give some other examples. Amongst them, e.g. chain of header reduces
   performance - one cannot just multiply second nibble like in IPv4 to get
   payload offset - multiple cache line loads may be needed to traverse the
   chain. Ironically, again, there were IPng proposals with variable address
   length, which were ditched with "fixed length is faster to parse"...

   Interestingly, that wasn't the first time of variable-length address idea:
   TCP/IP version 3 [IEN-21] in 1978 already proposed addresses 1 to 15 bytes
   length - which, if adopted, could save us all from NATs and IPv6 in the
   first place...

   So let's say final "NO!" to all opponents of variable-length addresses:
   for Internet to be really mix of *different* networks this is a must.
   Hardware producers blaming for performance must justify earning their
   salary, that's their problem, not of all others. Moreover, hardware evolves
   over the time more rapidly then protocols, so making assumptions about
   hardware capabilities at the time of protocol designing is not far-sighted.

TODO 08.12.25 include that actually we have 1475 NHFI field for them to not deal

   IPnh borrows ideas from Huawei's NewIP and IPng proposals which were
   alternatives to IPv6: IPv7 [RFC 1475] and Pip [RFC 1621][RFC 1622]. It's
   not surprising why Pip losed the contest to simpler proposals like SIPP:
   Pip as-is is really too complex to implement, with all of it's routing
   chains and even special servers for formatting Pip headers (violating
   end-to-end Internet principle, is now considered bad). However, it has
   many actual things, most notable mobility ID and same subscriber's part
   under different providers in hierarchy.

2. Concepts and header.

   Conceptually, IPnh tries to go radical: what if, for greatest extensibility
   possible, we represent packet as JSON ? This would eliminate need for
   newer IP versions for many decades, if not centuries! And possibility to
   support non-host addressing modes, e.g. [Named data networking]...

   Of course, this contradicts effective machine processing. And there are
   at least two conflicting areas of machine processing already:
   high-performance systems and constrained systems (like aforementioned
   802.15.4). Thus, IPnh copes with it by having different forms for same
   data.

TBD 20.10.24 Van Jacobson's network channels:
<<One of the basic ideas behind AF_XDP dates back to Van Jacobson’s talk about network channels. It is about creating a Lock-free channel directly from driver RX-queue into an (AF_XDP) socket.
[...]
The transport signature that Van Jacobson talked about, are replaced by the
XDP/eBPF program choosing which AF_XDP socket to XDP_REDIRECT into.>>
- This refers http://www.lemis.com/grog/Documentation/vj/lca06vj.pdf slide 26:
<<socket “registers” transport signature with driver on “accept()”. Gets back a channel.>>
...so - what if in the future computer will like HPC cluster today? so kernel
is just a router, and a hierarchical address is for everything, no TCP/UDP
ports!
BTW, in muSCTP `ServInstNum` is (independent) idea of something similar to
those independent sockets in Van Jacobson's talk.
<<It is, he says, simply the end-to-end principle in action yet again. This principle, which says that all of the intelligence in the network belongs at the ends of the connections, doesn't stop at the kernel. It should continue, pushing as much work as possible out of the core kernel and toward the actual applications.>>

TODO 30.11.24 paragraph about OSI wrong and new (sub)Layers: 2.4 - ARP,
2.6 - Forwarding, 3.4 - ICMP, 3.5 - Packetization
- TBD separate bit for ICMP ? and combine DHCP into ICMP ? ICMP doesn't need
  fragmentation and E2E Options - reuse fields?
  - but `ping` is used for fragmentation tests also
    - use new ECHO protocol instead of free'd ICMP entry?
      - or DIAGNOSE/SIMULATE ? not only echo, but also discard, mb other replies...
        - yes, this is really better then ICMP Echo, because you can't receive
	  ICMP to ICMP, e.g. "MTU exceeded" for 2000 byte DF ping
        - 01.12 seems it's ERR.. may be UDP echo/discard ports are better?
  - 20.07.25 given variant 26.11.24 for fragmentation, may move FrL to Flags
    and then combine it with E2E Opts as fragment offset, 10 bits: so we can
    have at least 4096 bytes (usable for DHCP), but probably need to change
    Frg here to another meaning
    - what to do with L3.5Len then? combine with offset? unbeautiful...
    - what if balancers still may need of beginning of packet copy which
      contained in many ICMP messages? still put into L3.5Len ?

2.1. Overview of packet and main concepts.

   IPnh packet has the following general structure:

      +=====================================+
      |                    |  Fixed Part    | \
      |   Initial Header   +----------------+  |
      |                    |  Variable Part |  copied in
      +=====================================+  every fragment
      |       Fragment Descriptor and       |  |
      | Balancer ("L3.5" - L4 helping) Part | /
      +=====================================+
      |                                     | \
      |       End to End Options Part       |  |
      |                                     |  |
      +=====================================+  |
      |                                     |  every fragment has
      |                                     |  different part of it
      |               Payload               |  |
      |                                     |  |
      |                                     |  |
      +=====================================+ /

   As fragmentation is an important part of IPnh, there is special part in
   packet if it is fragmented. To solve most of fragmentation problems
   described in [RFC 8900], author has found that it is enough to repeat first
   payload bytes in every fragment instead of putting them in just first
   fragment only. This is the place where middleboxes like e.g. firewalls and
   load balancers will look for them like if were beginning of payload, so
   it's also called "balancer part" on a figure above.

2.1.1. Host ID: fragmentation and mobility.

   Unlike Pip, where addresses were something second-class and used just for
   routing and first-class citizens were IDs, IPnh reverses this: due to need
   for compatibility with legacy addressing schemes, main focus is still
   on addresses. However, Host IDs - Source ID and Destination ID - remain an
   integral part of IPnh. Fragmentation, load balancing and host mobility all
   deal with Host IDs instead of addresses, like them would be primary
   identificators for hosts. Moreover, pseudoheader for TCP, UDP and other
   upper-layer protocols consists of Host IDs, so neither checksum
   recalculation will be needed when mobile host changes it's address, nor
   firewalls / load balancers need to lose their state.

   It is tempting to take EUI-64 as natural identifier for Host to be globally
   unique for mobility. However, one of IPv6 design flaws was exactly this:
   take MAC address as part of IPv6 and have privacy / tracking problems.

   So security lesson has been learned, and now Host ID is either:

   * explicitly selected by host and present in packet, or
   * absent in packet and calculated as hash sum from address.

   Note that transit routers do not need to calculate these hashes, just as
   they don't need to look into payload, even if such a router fragments
   packet, so performance here is not affected. Only end hosts and
   refragmenting instances like firewalls or load balancers need to - however,
   fast hash function do not add much for ability to seriously reduce latency
   for mobile hosts, so this is good trade-off.

TODO IPv6 mobility is triangular in best case - fundamental latency proble

TBD comparison with HIP (Host Identity Protocol), RFC 4423
and with LISP (Locator/ID Separation Protocol), RFC 6830

TBD draft-herbert-intarea-ila-01 : anycast, SIR prefix, ILA domain

TBD 30.11.24 Shim6, as defined in [RFC5533]: Section 6.6 of RFC 9049 lists <<that the problem being addressed was "site multihoming", but Shim6 was providing "host multihoming". That meant that the decision about what path would be used was under host control, not under edge router control. [...] that operators were performing traffic engineering on traffic aggregates. With Shim6, these operator traffic engineering policies must be pushed down to individual hosts.>> -- and 6.6.3 addendum (on prohibiting users to do market economy choices) is very funny:
<<6.6.3. Addendum on Multipath TCP

During discussions in the PANRG session at IETF 103 [PANRG-103-Min], Lars Eggert, past Transport Area Director, pointed out that during charter discussions for the Multipath TCP Working Group [MP-TCP], operators expressed concerns that customers could use Multipath TCP to load-share TCP connections across operators simultaneously and compare passive performance measurements across network paths in real time, changing the balance of power in those business relationships. Although the Multipath TCP Working Group was chartered, this concern could have acted as an obstacle to deployment.
Operator objections to Shim6 were focused on technical concerns, but this concern could have also been an obstacle to Shim6 deployment if the technical concerns had been overcome.
[...]
6.7.1 [...]
Operational Aspects: NSIS not only required trust between customers and their provider, but also among different providers. In particular, QoS signaling techniques would require some kind of dynamic SLA support that would imply (potentially quite complex) bilateral negotiations between different Internet Service Providers. This complexity was not considered to be justified, and increasing the bandwidth (and thus avoiding bottlenecks) was cheaper than actively managing network resource bottlenecks by using path-coupled QoS signaling techniques. Furthermore, an end-to-end path typically involves several provider domains, and these providers need to closely cooperate in cases of failures.
>>
- 05.12.24 (see also this day) capitalism is over, so
  "Возможность переиспользования полосы, на которой все и зарабатывают (благодаря чему IP и выстрелил), при этом сохранялась. [...] до установки TCP сессии или до начала обменом данными, конечные хосты отправляют RSVP Path с указанием требуемой полосы [...] требует ненулевых затрат CPU и памяти на каждом транзитном узле, а также откладывает фактическое взаимодействие на некоторое время" [https://linkmeup.gitbook.io/sdsm/15.-qos/1.-tri-modeli-obespecheniya-qos/1-intserv]
  is now should be viewed from only technical side (scalability etc.), not
  business
- 07.12.24 technically, pushing policy information to end hosts is problematic
  due to needs for Host software updates, and this is different administrative
  boundaries than network's routers. Thus, we have only provider-aggregated
  addresses, but force that host MUST reserve space in header for longest of
  prefixes (if packet goes outside) for router to be able to rewrite source
  IPnh address (for controlling return channel traffic). As mobility is
  inherent in IPnh and every Host MUST accept packets with it's destination
  HostID, regardless of destination IP address (still analogy with paper mail,
  Host is human but address is just location), everything will work - so we
  will have PA addresses only. Note that ability to regulate return-traffic on
  a per-packet basis gives network administrator even more control on channel
  load than possible in BGP4 with PI addresses, where granularity for the same
  (PI) IP subnet, by path-prepending, is per-destination AS at best, if not
  per-provider channel only like "this ISP is primary and this is backup".
  - 12.07.25 another possibility is ICMP message from border gateway
    "use this prefix for your 5-tuple", with TTL and boolean whether original
    packet was dropped (need retry) or just switch for next packet; other ICMP
    message should be about HostID collision - see IP45 proposal for SIDs
    TBD check about security there


2.1.2. Addresses: hierarchy, compatibility, extensibility.

   One of the IPnh goals is not only simplify address space and routing
   management by hierarchies, but also provide a "natural" way for presenting
   addresses of different types (become really *inter*-net again), including
   IPv4 and IPv6 addresses in such manner that hosts with such addresses and
   IPnh hosts can communicate without need dual-stack (triple-stack, etc.)
   support in each host, that is, without modification of hosts' software
   (except, may be, easy little parts like DNS resolver).

TBD which variant to take for compatible v4/6 ? tag 52/54/260 to string?
top-level in hier?

top-level: mb 4. for IPv4, 6 for IPv6, 11..17 for telephone codes like +7... ?

   Address allocation ot top of tree is supposed ot be "RIR.LIR.provider", or
   more precisely, top number being continent or some other type, e.g. 4. for
   IPv4 and 10. for private networks.

- variant: shortcuts for 4 one-byte elements and 8 two-byte elements
  so 4.200.200.200.200 for IPv4 and 34.200.200.200.200 generic both could
  take 6 bytes; same for MAC / EUI-64 ?


a file system metaphor
  /usr/share
  /usr/src
  /builder01/src/
  /builder02/src/

Host id as st_dev + inode?
- 20.10.24 or opaque is more simple/secure? and don't require management of IDs
  - st_dev may be used in routing protocols - where one subscriber "mounted"
    to multiple providers

with LDAP, there is no more file and directory distinction, also ReiserFS

TBD LDAP has multi-valued RDN, should we generalize it?
- seems not, "," is enough, other is not simple to implement

. as 0, .. as 1 and ../.. as 2 ?
**/ for anycast?
- 20.10.24 or anycast can be "symlink", invisible to sender
  - however response "here is nearest to you" may be more efficient
    - but may be policy-disabled due to security concerns

it is tempting to mix layers having addresses of sockets, but Lindy Effect
- but see 20.10.24 of Van Jacobson... at least port compatibility for
  transition period?
  - 22.10.24 what if BGP load balancing of *outgoing* traffic is used by e.g.
    source ports? then having it at end of address will require non-contiguous
    masks if existing radix trie algorithms are utilized... so better to view
    different OSI layers as different dimensions?..
    - but is such poor traffic engineering method a justify to prohibit?..
  - 25.10.24 if do, then Host IDs are naturally generalized to Umbrella IDs:
    host, cluster, department, organization...
    - however, currently it's impractical as only Host could be mobile
      (reconnect on different hierarchy subtrees) - but who knows if in the
      future organizations also can easily get new providers connections
      "on the fly" ?

HIP says about mixing two layers, address and identity, but itself ironically mixes identifier with crypto key

    ^
TBD | 25.10.24 ~22:00 a ThSC point in a roaming from Home node is conceptually
    v   same situation as an IP host moving from 3G to WiFi link without
        connection interruption so Host IDs are here; however, differences are:
	1) Host ID ~= SSH key - is for one online device of several, here,
	   it's like Anycast for online packets
	2) for mail/offline data, it's like a Multicast now

Pip:
===
   Thus, the basic form of a Pip address is:

         providerPart,subscriberPart

   where both the providerPart and subscriberPart can have multiple
   layers of hierarchy internally.

   A subscriber may be attached to multiple providers.  In this case, a
   host can end up with multiple Pip Addresses by virtue of having
   multiple providerParts:

         providerPart1,subscriberPart
         providerPart2,subscriberPart
         providerPart3,subscriberPart
...
   For instance, if two neighbor routers have Pip Addresses 1.2.3,4 and
   1.2.8,9.14 respectively, then they share levels 0 and 1, and are
   different at levels below that.  (0 is the highest level, 1 is the
   next highest, and so on.) As a general rule, these two routers
   exchange level 0, level 1, and level 2 routing information, but not
   level 3 or lower routing information.  In other words, both routers

   In this case, 1.2.8,9.14 does not need to know about level 2 or level
   1 areas in the provider (that is, it does not need to know about
   1.2.4..., 1.2.5..., or 1.3..., 1.4..., and so on).  Thus, 1.2.8,9.14
   should be configured to inform 1.2.3,4 that it does not need level 1
   or 2 information.
===
TBD 21.10.24 do we need "," in *packet* address encoding at all? filesystem
metaphor allows for host to send to "../../dest/server", making it natural for
IoT-constrained networks having short addresses, and let's routers to deal
with who is mounted to who at absolute addresses, not complicating address
encoding with CBOR tags. So there will be just a few special numbers for ".."
and "*" and may be "+" or "#" from MQTT, need more thinking here - but no more
wasting a bit or entire byte just for "," tag.
- "../style" is good for IoT, but it is essentially one-hop: router later in
  chain will probably have another prefix so ".." will become invalid if
  packet is not rewritten. May be better to have 3'rd element as common prefix
  for address compression? Or series of routing instructions with DNS-like
  label compression? However, such source-routing instructions also require
  a pointer "where we currently are at", which again is not very performant.
  Still, in a snail-mail/courier metaphor it is possible to not include
  country and town if delivery is in the same town - so inside one corporation
  or IoT PAN-network should be possible also, modulo fact subscriberPart may
  be connected via several global prefixes, like "in same mounted filesystem".
  Need to look closer to Pip and RFC1475 in more detail...
- 22.10.24 metaphor: address is like street, ID is like First Name Last Name
  on envelope - could be registered in this house, could be not; having
  memcmp()-comparable addresses - utilize existing radix tries just rounded
  to 8 bits instead of as in CIDR

TBD 25.10.24 05:09 it should be done the way when it simply is not possible to
spoof source IP address, thus flooding DDoS-attacks will die in the past
- 29.10 if this is path in tree (addrs combined), then how to force router to
  check incoming packet is not of spoofed path segment? In current Internet,
  reverse lookup is not done for performance reasons but this also allows
  mobile hosts (triangle); here, we can have Host IDs for mobile, but how to
  force, still? OK, it can't be full path that verified (e.g. rogue routers),
  but at least at first lawful router (so traceable entry point of spoofed
  flood) - how to make it that without path element validity check the whole
  system will simply not work?..
  - 09.11.24 yes, relative addresses and current pointer for receiving router
    "you are at this position": e.g. D.E.F -> K.L.M.N and if there are
    addresses X.2.2.2.2...2 and Y.2.2.2.2...2 it will be impossible for
    receiving router to distinguish relative prefix without pointer; even if
    E router has direct link to L router, it just advances pointer by 3
    instead of 1; so now spoofed addresses can be only A.B.C under D.E.F if
    all routers are lawful and spoof is from distinct branch. Rogue router can
    inject D.E.F->K.L.M.N directly to L router, or it can be L's client, but
    now it needs to be near destination. This does not prevent spoofing
    completely, but greatly reduces sets of addresses available to attacker,
    in contrast to current Internet "any spoofed src IP from anywhere", while
    being not much harder for usual routers' operations than decrementing TTL,
    but allowing all the Pip relative intra-organization addressing (helping
    to e.g. renumbering problems) with it's bonuses. Now, need a way to find
    "entry points" of spoofed addresses into network - on which lawful router
    via which link that happened, possibly by signaling within a routing
    protocol - and DOTS [RFC 9132] protocol signaling seems far from this...
    - 13.11 link from E to L may be via router from completely different branch,
      e.g. our example was for absolute addresses T.T.F.E.D to T.T.K.L.M.N and
      T.T.F.E has route to T.T.K.L via T.S.P.Q
    - 14.11 also, hierarchy assumes that there is spanning tree for entire network
      graph with always a link to parent, but this link can go down - so there
      is a need for a packet from T.T.F.E.D be routed to T.T.F.H when F<->E
      link is down and relative addresses where E.D -> H (for example, again
      via T.S.P.Q)... Moreover, what happens if the only route left available
      is not via T.S.P.Q but even via descendant of T.T.F.E, i.e. packet must
      for some time travel lower in the hierarchy?..
      - metaphor for in-capital mail tunneled via suburb when bridge burned
    - 15.11 if tunneling, then it is VPN-like or MPLS-like using of Next Hop
      and relative adresses become irrelevant for intermediate routers, now
      they are used only by end routers and clients
      - 16.11.24 need a way for simplified routing without MPLS-like Next Hop,
	e.g. for (compatibility with) constrained hosts (different HCver), so
	current pointer again? Need to re-consider spoof in this case
    - but what prevents malicious client from giving absolute dst address so
      lazy router does lookup only on destination?
      - make address always relative, so client router will have to compare
	it's own interface address' tail with source address, and end client
	host thus must specify real interface address prefix for router's
	comparison to succeed - so antispoof anti-DDoS goal is achieved

  Absolute level 0 (@root)    T
                             / \
                            T   S
                           / \   \
  Relative Level 0        F - K   P
                         /     \   \
  Relative Level 1      E ----- L - Q
                       / `.      \.-'
                      /    \    /'\
  Relative Level 2   D      `--'   M
                                    \
  Relative Level 3                   N


TBD renumbering problem: if one company has 10,12.3.4 and other has 10,12.4.1
then on merge acquisition they'll have overlapping addresses (problem in
current IPv4/IPv6 with even possible need for internal NAT); in Pip this is
not problem while hosts talk inside their own net with relative addresses, but
when to other? So need mechanism for all hosts to seamlessly be configured
like "change our prefix from 10,12.3 to 10.192.12.3" - as it is similar in
spirit mobile hosts, should be doable, but need to think details (and this is
thus a MUST to have relative addressing as in above paragraphs)
- e.g. https://t.me/freebsd_ru/584396 (свиноферма / CARP)
  - 15.11.24 multiple networks on same physical L2 interface are allowed under
    restriction that no address is prefix of another address, so that CARP
    scenario with L2 bridged triangle should be doable with proper addresses
    selection
- 12.07.25 http://ip45.org/wp-content/uploads/2013/12/paper-emfonts1.pdf :
  <<one of the key advantages provided
by NAT is the *address independency* and *reusing single IP
address* by many devices. In practice, it does not matter how
many NATs are connected in the chain and the IP network
topology can be arranged into hierarchical and recursive struc-
ture as shown in figure 1. The remaining benefits provided
by NAT are, generally, the result of the two main attributes
mentioned before. In a very easy and cheap way, the *address
independency* allows us to implement features like small site
multihoming without running a BGP router [10], or to change
the upstream ISP without the readdressing of all devices.
Another frequent reason for using NAT is the consequence
of *reusing a single IP address*. Firstly, it hides the internal
structure of the network and secondly, it forbids a connection
with a device in the NATed network from the outside. Both of
them are considered as security features.>>

TBD 04.11.24 uni-flow TCP3-like, CCCP and RFC 3124 (Congestion Manager):
<< sender and receiver.  For the Internet to remain stable, each of
   these streams must incorporate control protocols that safely probe
   for spare bandwidth and react to congestion.  Unfortunately, these
   concurrent streams typically compete with each other for network
   resources, rather than share them effectively.  Furthermore, they do
   not learn from each other about the state of the network.  Even if
   they each independently implement congestion control (e.g., a group
   of TCP connections each implementing the algorithms in [Jacobson88,
   Allman99]), the ensemble of streams tends to be more aggressive in
   the face of congestion than a single TCP connection implementing
   standard TCP congestion control and avoidance [Balakrishnan98].
>>
- 05.12.24 see CCCP block (now Centralized Congestion Control ) in musctp_draft.txt,
  as capitalism is over, RSVP/IntServ may be resurrected on new level; primary goal
  is consolidated network: "социализм возможен в одной, отдельно взятой, сети"

===
RFC 3649:
   In order for best-effort flows to safely start-up faster than slow-
   start, e.g., in future high-bandwidth networks, we believe that it
   would be necessary for the flow to have explicit feedback from the
   routers along the path.  There are a number of proposals for this,
   ranging from a minimal proposal for an IP option that allows TCP SYN
   packets to collect information from routers along the path about the
   allowed initial sending rate [J02], to proposals with more power that
   require more fine-tuned and continuous feedback from routers.  These
===

RFC 950:
   | This is a significant advantage, that given the Internet
   | address no additional information is needed for an
   | implementation to determine if two addresses are on the same
   | subnet.


TBD

2.1.2.1. Packet exchange with current Internet - transition.

   This is, of course, done via NAT. For IPnh networks, IPv4 and IPv6
   addresses look simply like in a subtree - e.g. as 4.1.2.3.4 for IPv4
   address 1.2.3.4 or 6:2001:db8:85a3:8d3:1319:8a2e:370:7348 for IPv6
   address (it is also possible that provider/organization will use not global
   prefix 4. or .6 but with some local prefix prepended to it, for users to
   save some bytes in header by not needing to specify path from root,
   especially if more than one prefix is assigned). So IPnh host software does
   not require changes except at DNS resolving - knowing that A should be
   actually prepended with (provider_prefix.)4. and (provider_prefix.)6. for
   AAAA records. Then NAT at nearest router knowing route to those prefixes
   does translation only of L3 headers, subject to well known rules. Note that
   no dual-stack on IPnh host is required, except may be for binary
   compatibility with older applications compiled for AF_INET/AF_INET6.

   For IPnh going as clients to outside IPv4, things look much the same as if
   were just IPv4 clients on a typical gray network - NAT will translate their
   addresses to some public IPv4 addreess(es).

   For later times, e.g. when most of Internet migrated to IPnh, or there just
   some IPv4-only devices in an environment of IPnh, the opposite NAT is
   taken: at IPv4 router, being border router for this IPv4 subnet, runs a NAT
   and DNS interceptor instance. The DNS resolver, which must be only resolver
   configured for these IPv4-only hosts, translates IPnh DNS address records
   into A records in the 26.0.0.0/8 network and installs corresponding mapping
   into the NAT engine. Outgoing packet to 26/8 then routed to NAT and gets
   translated to IPnh address, and vice versa.

   Of course, this supports only outgoing connections via DNS and requires DNSSEC
   disabled, but DNSSEC is brain-damaged anyway (see e.g. DNSCurve for better
   alternative). However, this covers vast majority of use cases achieving
   interconnectivity between address families WITHOUT any modification of host
   software - something IPv6 failed to do, thus being major slow-down factor
   for IPv6 deployment even in the era when all IPv4 address space is
   exhausted at RIR level.

   As there is only /8 "stolen" IPv4 network for translation needs, this
   limits connectivity from IPv4 "island" to only about 16 millions of IPnh
   hosts simultaneously, so it is expected that this translation will be
   deployed at CGNAT level or below. Note that such IPv4 "island" continues to
   retain connectivity with all other public IPv4 space, so transition can be
   gradual and painless.

   The same technique could be applied to IPv6, just selecting larger prefix
   for translation - or, as vast majority of current IPv6 hosts are
   dual-stack, only IPv4 part may be selected for deployment, saving
   development hosts.

2.2. Common parts of all headers.

   All IPnh header formats have first two bytes in common:

    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
   |Version|  IHL  | HCver |Frg|ECN|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...

  Version:  4 bits

    The Version field indicates the format of the internet header.
    For this draft, the version later assigned by IANA will be either 8, as
    the successor of the Pip and letter "h", or 3, with network as "tree"
    and continuing some things from TCP/IP version 3.

  IHL:  4 bits

    Initial Header Length, or some part of it, in units depending on HCver.

  HCver:  4 bits

    This is not a minor version, but a Header Compression scheme combined with
    scheme version (cf. 6LoWPAN's HC1, HC2, IPHC, NHC...). All variants of
    HCver are still the same IPnh version header and consist of conceptually
    the same data, but represented in different forms. For example, a gateway
    between "big" Internet and constrained segment can statelessly transform
    packet from one header format from another.

    This drafts currently defines HCver 0, 1 and "maximal CBOR".

  Frg:  2 bits

    Whether Fragment Descriptor is present or unfragmented, and fragment type:

    00 - unfragmented datagram
    01 - first fragment
    10 - last fragment
    11 - "middle" (neither first nor last) fragment

    Note that this is in fact bits B(egin) and E(nd) inverted to make simple
    test for presence of Fragment Descriptor by checking field to be non-zero.
    Every Header Compression scheme MAY define different Fragment Descriptor
    formats for these 3 combinations.

TODO 18.09.24 redo for "0 unfragged, other fragged but exact depend on HCver"

  ECN:  2 bits

    Explicit Congestion Notification bits, placed at the same place and having
    the same meaning as in IPv4 header.

TBD RFC 4782 "Quick-Start for TCP and IP" - what if integrate this in every
packet into unchecksummed "On-Path modify" word instead of ECN? together with
MTU; however, long nonces and other abuse/lying preventing measures are
required...
   The Performance Transparency Protocol (PTP) includes a proposal for a
   single PTP packet that would collect information from routers along
   the path from the sender to the receiver [W00].
   ETEN:
   Additional proposals for end nodes to collect explicit information
   from routers include one variant of Explicit Transport Error
   Notification (ETEN), which includes a cumulative mechanism to notify
   endpoints of aggregate congestion statistics along the path [KAPS02].
   (A second variant in [KSEPA04] does not depend on cumulative
   congestion statistics from the network.)
-- and other listed in Appendix A there are interesting
02.12.24 there referenced MaxNet (e.g.
http://web.archive.org/web/20060909055743fw_/http://netlab.caltech.edu/maxnet/MaxNet_Implementation_TechReport.pdf)
looks more promising than XCP: very simple implementation in router, jsut
3 byte `price` and `echo` fields, but unstable to packet loss and still no malicious
protection (XCP also hasn't)

- 22.10 also checksum for very short:
===<<
Cohen & Postel                                                  [page 1]
                                                              2 May 1979
Multiplexing Protocol                                             IEN-90
Introduction

The  demultiplexing   routine  should  be  able  to  handle  recursively
multiplexed  messages.   This is  to  allow  higher  level  protocol  to
demultiplex  their own messages  if they can be combined.   Since such a
multiplexed  message  may be  multiplexed  again  by  the  IN  level,  a
multi-level multiplexing results.

This protocol  assumes  that  the  Internet  Protocol  is  used  as  the
underlying protocol.

Format
------

                  0      7 8     15 16            31  
                 +--------+--------+----------------+ 
                 |        |        |                | 
                 |   CS   |Protocol|      Length    | 
                 |        |        |                | 
                 +--------+--------+----------------+ 

                       Multiplexing Header Format
Fields
------

CS is a checksum  covering  only this 32 bit multiplexing header.  Until
further notice, it is the exclusive OR of the other three octets in this
header.
===

   The ECN field expected to be here in constrained profiles, "big" versions
   expected to use this bits for something else, while spending more than
   2 bits for congestion info from newer research, being not limited to
   IPv4/IPv6 ToS/DSCP byte legacy.

TBD

2.2.1. Coloring word.

   In some header variants a "coloring word" (like "green traffic" or
   "red traffic") could be placed.

   This word is usually last and optional, it is present only if IHL is large
   enough AND that space is not consumed by addresses, IDs and short options.
   If it is not present, it MUST considered as containing all-zeroes. Meaning
   of fields is the same as Flow Label and Traffic Class in IPv6, except that
   it's "Traffic Class" expanded to 12 bits and divided into two fields: one
   coloring for technical needs (6 bits of traditional DSCP) and one (new)
   field for non-technical (legal) coloring.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    DSCP   |R|L/GovMark|           Flow Label                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

  Traffic Class and Flow Label:  6 bits.

    Traffic Class does not contain ECN and reserved bits are meant for aid in
    load balancing also, e.g. it may be expanded to full 12 bits instead of
    just 6 bits of current DSCP.

TBD 22.10.24 given RFC 1621 Section 7, put Ver here, and for zero ver ECN with
DSCP/Label as for compatibility with current IPv4/IPv6 ?
- 15.11.24 not quite, if this just 1 word, it will be in "legacy format" as in
  IPv6 first word, with ECN here, and GovMark in place of IP version;
  otherwise need some format indicator and may be even options inside - for
  recording On-Path info from routers, more info on congestion from routers
  than just CE, more coloring than in DSCP, etc.
  ...should we allow all IPnh implementations MUST support ECN, so that absence
  of L3.5 part, meaning all fields equal to default zero, may be "fixed" by
  transit router by inserting this word with CE value?
TBD 26.11.24 (see this day) a bit L for larger identification here? or it will
be difficult to find extended fragment Identification

  R:  1 bit

    Reserved for future use, MUST be 0 on send and ignored on receipt.

  GovMark:  6 bits.

    Government or Local Policy Mark is meant as a compromise between
    conflicting legal and moral requirements. While Internet always was been
    for global connectivity and against censorship, and that was supported by
    using cryptographic means to prevent e.g. tampering of the packet, there are
    still valid cases when middleboxes could do something to packets instead of
    dropping (philosophically like ECN field added instead of dropping) to let
    end-system (or near-end system) to decide. Most notable example of this is
    "adult content" where for many people it is normal but parents may want to
    enable filtering which may be infeasible to do (on the Internet scale) on
    end children's device. In case of government-level censoprship, using
    cryptography and other hiding tools usually leaves the only choice for
    censors to block traffic completely, an "all-or-nothing", because e.g.
    HTTPS do not allow them to add "COURT DECIDED THIS IS FAKE NEWS SITE"
    Big Banner or something like that to web page. We believe that adding such
    outside-of-content markers could reduce level of censorship blocks in the
    world.

    A big enterprise network could also make benefit on simplification access
    rules by marking traffic by e.g. access levels, thus this field could also
    be used not only Government but as Local Policy Mark, too. This is in
    spirit of early days of IP when some bits of TOS field where for
    confidentiality level.

    This draft do not specify values to this field except that zero (0) MUST
    mean absence of any legal/policy mark, and decimal 24 is RECOMMENDED for
    "adult" traffic (so that with default traffic class 0x018 on the wire could
    be easily identified as not for children under 18 years).

  Flow Label:  20 bits.

    Same as in IPv6.

TBD 30.11.24 RFC 6437 essentially defines flow label as a crutch against
fragmentation, even examples as hash function (von Neumann) from 5-tuple
(BTW this function may be useful in other contexts, not this header), or
another application is for flows outside of IPsec (where full is hidden)
so it's probably doesn't make sense to expand this field

TBD 29.06.25 an "out-of-order possible" flag as indicator from round-robin
balancers - in current Internet this affects baldy TCP performance, but
flow-based balancing not always possible (tunnels etc.)

TODO

2.3. Optimized for performance header: HCver=0.

   This is variant of header intended to be most common, in "normal"
   Internet - 0 as "Old" / "Optimized" for performance. It can be seen that
   some fields are at the same place as in IPv4 header, with same meaning.

   Here, length unit, word, is defined as 32 bits.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Version|  NHL  | HCver |Frg|FrL|          Total Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |IHL=L3.5 Offs|   L4 Protocol   |Flags|E2E Opts Len | SIL | DIL |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Hop Limit (TTL)|Routing Context|    SAL    |    DAL    |L3.5Len|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   . Next Hop / Forward Route Instructions - to NHL words boundary .
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ <-- NHL
   |                                                               |
   .             Source Host ID - optional, SIL words              .
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   .           Destination Host ID - optional, DIL words           .
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   \                                                               \
   /          Source address (variable length, SAL bytes)          /
   \                                                               \
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   \                                                               \
   /       Destination address (variable length, DAL bytes)        /
   \                                                               \
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   \                                                               \
   /              Every fragment (Hop by Hop) options              /
   \                                                               \
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ <-- IHL
   |                                                               |
   .       Layer 3.5 (Layer 4 helping) part (Coloring words)       .
   .              optional, L3.5Len-(Frg?1+FrL) words              .
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   .       Fragment Descriptor, if fragmented - FrL+1 words        .
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ IHL+L3.5Len


  IHL:  7 bits

    Initial Header Length is in 32-bit words, like IPv4, but six bits.
    That is, maximum length of initial header is 508 bytes, and IHL
    value MUST NOT be less than 4.

    As L3.5Len is distinct from IHL, the minimum MTU REQUIRED to be 576 bytes
    to be also possible to include maximal-sized Layer 3.5 part and some
    fragment bytes. Rationale to excluding L3.5Len from IHL is to allow 264
    bytes of options on maximal sizes of NHL, SIL, DIL, SAL and DAL
    (60+28+28+64+64=244), of which single long options block header will leave
    256 guaranteed bytes for option values.

TBD IHL+L3.5Len is for BPF_LDX|BPF_MSH|BPF_IND: X <- X+4*(P[X+k:1]&0xf) from BPF64

  Flags and Reserved:  8 bits
===
      o The GUE header includes a header length field. This allows a
        network node to inspect an encapsulated packet without needing
        to parse the full encapsulation header.

      o The flags-field model facilitates efficient implementation of
        extensibility in hardware.

        For instance a TCAM can be use to parse a known set of N flags
        where the number of entries in the TCAM is 2^N.

        By comparison, the number of TCAM entries needed to parse a set
        of N arbitrarily ordered TLVS is approximately e*N!.
===
TBD "Options Present" bitmap is also in PIP - combine somehow

    TBD

  NHL:  2 bits

    Length of Next Hop field in 32 bit words. May be 0 for absence of Next Hop
    field, the most common expected case, or 1 or 2, for 32-bit of 64-bit
    Next Hop. Value 3 is currently reserved and MUST NOT be used (it's not
    decided yet to be 3 words or 2^2 words).

TODO 18.09.24 move this length outside of other lengths: as it is essentially
like VLAN tag or MPLS label, it will be used by intra-AS routers in links with
larger MTU when end host may already filled up other available space with
addresses/options; also CW for coloring word as also addition to length
- TBD 23.10.24 https://www.ietf.org/archive/id/draft-bryant-arch-fwd-layer-ps-05.html
  says that many length are not enough (esp. MPLS), so let's increase it!
  - TBD 03.11.24 or put into IHL real offset to some part e.g. end of
    identifiers? better for entire header to have 1-byte-described length,
    even better to fit into one mbuf
TBD 20.11.24 ~02:20 NAIR - Nibbles/Nested Arrays of Integers Representation, like CBOR:
  0 - number 0 and false
  1 - number 1 and true
  2..9 - integer of n-1 nibbles - so 2^32 max
  a - array of 0 elements
  b - array of 1 elements
  c - array of 2 elements
  d - open '[' for indefinite-length
  e - reserved for extension in next nibble
  f - closing ']'

  DIL and SIL: 3 bits each

    Destination Host ID length and Source Host ID length, in words. If length
    is 0, then ID is absent from packet and is instead calculated from full
    host address. Hash algorithm (and possibly key/nonce) may be overriden by
    short option in "Every fragment options", but by default is SipHash-2-4-128
    with a key being "IPnh\0\0..." (four characters "IPnh "padded by number of
    zeroes required by algorithm).

    Note that Host ID can be unambiguously calculated from full address only
    if host has only one address (one provider for organization). Otherwise,
    it SHOULD be always included.

    Variable length for Host ID is intended for possibility of hierarchy:
    organization's ID, sub-organization(s) ID, host with organization ID. So
    with 32-bit values it is possible to have up to 6 organiztion levels (for
    support of merge/acquire, etc.). However, transport protocols should view
    IDs as just opaque bytestring.

TBD 19.09.25 21:20 what if make it DNS label? Of course not arbitrary, but
few non-fixed lengths labels under e.g. .hostid.arpa.
- 30.09.25 for privacy reasons, share 0-max with Connection Tag?
  - or just use fake Host ID for each bunch of connections?

TBD 03.11.24 put MTU into On-Path field when gets fragmented by router

  L3.5Len:  4 bits

    Length of balancer/L4 helper part together with fragment descriptor, if
    present. If, after subtracting fragment descriptor, length is 1 word, then
    it is Coloring Word in legacy compatible format.

  Flags:  3 bits

    TBD

  Options Length:  8 bits

    Length of options, in 32-bit words. Thus, options may have length from
    0 to 1020 bytes.

  DAL and SAL:  4 bits each

    Destination and Source addresses length, in elements.

TBD 18.09.24 may be 1..17 bytes? enough for "tag+IPv6" Aug2024 TBDs in 2.3.1
- this means minimum address length is 2 bytes
- 16.11.24 make it 6 bits, in bytes+1 (1..64) and contents being
  variable-length integers, encoded as UTF-8 in it's original RFC (not current),
  that is, allowing to 2^31 on every level. This is fat (3 bytes for 16 bits)
  but needed for error-checking, HCver for constrained nodes will have
  different encoding
  - or still limit and give some values for escape?..
    - 19.11 probably escape should be not "complete 6.ip6:addr:from:root" but
      rather shortcuts "here 4 single-byte ints/levels" or "8 16-bit levels"
      if, for example, future will need another global prefix than 6, or there
      will be other protocols - so for applications in sockets it's always full
      address in usual form, it's just wire compression at lower stack levels?
  - 19.11 make a paragraph about `struct sockaddr_storage` (<128) and apps
    compatibility so size limited (& to leave space for service names) and
    UTF-8 here also familiar to app developers

    Note that addresses in packet are always relative to their common prefix
    from root of the tree, even if that prefix is of null length (in this
    particular case adresses are absolute), so first router accepting packet
    from end host compares tail of it's own network with source address. See
    corresponding section on renumbering, intra-organization and anti-DDoS.

  Total Length:  16 bits

    Length of this IP datagram in bytes, as in IPv4.

  Hop Limit (TTL), Protocol, Header Checksum

    See IPv4. Differences are that Checksum does not cover TTL (as in IPv6)
    and does not cover Options Part with big options - there are special
    option there, as in DCCP, for their checksum and probably part of payload.

    Header Checksum, however, covers more than IHL words - there are also
    Coloring Word, Fragment Descriptor and Copy of L4 payload beginning, if
    fragment. That is, up to 2 + IHL + NHL + CW + (Frg ? 1+FrL : TODO) words
    (96 bytes max).

TBD 03.11.24 what if just one XOR byte instead of usual Internet checksum?
it's faster to incrementally update (e.g. TTL) even than RFC 1141 procedure
and has the same "is zero" property on check if correct

  Coloring word:  last 32 bits.

    For Traffic Class and Flow Label, optional, see section on coloring word.

  Next Hop / Forward Route Instructions:  absent or words up to 48 bytes

    This optional field, if present, contains information to be interpreted by
    next router *instead* of Destination Address, and possibly other
    variable-length fields/options (at the discretion of that router). Thus,
    if present, it is first in packet at fixed offset, facilitating
    forwarding plane performance. It is intended to be used like described in
    Section 3.4 of [RFC 1475], MPLS-like or instead of MPLS.

    This specification does not constrain how this field to be implemented,
    but possible suggestions could include even offset of routing entry in FIB
    memory region, the only requirement here is to include some error checking
    or authentication bits, so that:
    1) errors detected while routing protocol converges
    2) unauthorized end-user host (non-router) could not guess this field

    Note that, despite of name, this value is not restricted to be hop-by-hop
    or changed at every hop, so chain of routers in area from entry to exit
    could all use single value in this field, making variable-length
    addressing not slower, but even faster than traditional CIDR.

  Routing Context:  8 bits.

    Used for simplified routing schemes inside a controlled administrtive area
    where full routing protocol is not running and thus Next Hop words are
    absent. This field is expected to include some packet level or distance
    and thus changed at every hop, so it is placed near TTL.

    This field may be used with or without Next Hop. If in combination, it may
    serve as a "Content-Type" for Next Hop and/or some pointer within it.

    From security point of view, both Routing Context and Next Hop SHOULD be
    cleared to zero before delivering to final destination host, to prevent
    malicious cooperating hosts from guessing values to influence decisions on
    a (mis)configured first accepting router. If performance of such process
    is very critical but Next Hop is cryptographically verified, then it's
    usually enough to zero out just some bytes (one per several).

TBD

2.3.1. Addresses.

   For compactness, common CBOR types are optimized into custom format.

   First bits of element a

 0..159
 101aaaaa bbbbbbbb                                     - 13
 110aaaaa bbbbbbbb cccccccc                            - 21
 1110aaaa bbbbbbbb cccccccc dddddddd                   - 28
 11110aaa bbbbbbbb cccccccc dddddddd eeeeeeee          - 35
 111110aa bbbbbbbb cccccccc dddddddd eeeeeeee ffffffff - 42

 0..191
 110aaaaa bbbbbbbb                                                       - 13
 1110aaaa bbbbbbbb cccccccc                                              - 20
 11110aaa bbbbbbbb cccccccc dddddddd                                     - 27
 111110aa bbbbbbbb cccccccc dddddddd eeeeeeee                            - 34
 111111aa bbbbbbbb cccccccc dddddddd eeeeeeee ffffffff                   - 42

 0..191
 110aaaaa bbbbbbbb                                     - 13
 11100aaa bbbbbbbb cccccccc                            - 19
 11101aaa bbbbbbbb cccccccc dddddddd                   - 27
 1111xxxx aaaaaaaa bbbbbbbb cccccccc dddddddd ...      - 32..120 bits
 111111yy - specials

TODO must be 0xe0 for same 28 bits as IPv4 Class D Multicast
- 27.08.24 as only 23 bits is used in Ethernet, and not all blocks are
  assigned, this familiarity requirement is no longer of a priority, at least
  less important than single-byte addresses capacity

TBD what if make lengths external, as in SQLite row header, so SAL/DAL is
number of nibbles, each descirbing number of bytes?
- may be useful for constrained (IoT) format (HCver=1), but too complex for
  performance one, e.g. in common task "reverse source and destination";
  also constrained may utilize hextet-compressed from early BPF64
  - 13.06.25 01:24 what if just one bit in flags for reverse? will greatly
    speed up generating answer packets... but less easier for lookup by
    destination address... though Next Hop should mitigate this
- in fact, the primary representation, at conceptual level, is CBOR, even if
  particular optimized implementation will never do CBOR - so we don't need
  arbitrary formats here, like integers up to 128 bits for boths IPv6 and MAC
  addresses. Let's just do short forms for exact CBOR constructs, like
  "tagged string with IPv6 address" (and some codes reserved for extension)

 0..191
 110aaaaa bbbbbbbb                                     - 13
 1110aaaa bbbbbbbb cccccccc                            - 20
 111100aa bbbbbbbb cccccccc dddddddd                   - 26
 F4 - TBD either just 4 bytes or tag of IPv4 ?
 F5 -
 F6 - TBD here MAC addr or IPv6 tag?
 F7 - TBD do we need intermediate integer lengths in 40..56 ?
 F8 -
 F9 -
 FA - 4 bytes, CBOR 0x1a
 FB - 8 bytes, CBOR 0x1b
 FC - tag as comma (mnem: 0x2c)
 FD - Reserved for future use
 FE - escape to one CBOR element (though may be multiple tags)
 FF - escape to CBOR till rest of address

=== http://www.employees.org/~ravir/cbor-network.txt :
IPv4 Address is stored as 4 bytes.
IPv6 Address is stored as 16 bytes.
MAC  Address is stored as 6 bytes.

Tag value of 260 is used to mark that the following byte string data
is either a IPv4 address or IPv6 address or MAC address (depending on
the length). The addresses are stored in binary values in the network byte order.

Examples:
d9 0104 44 c00a0a01     --> IPv4 address 192.10.10.1
d9 0104 46 0123456789ab --> MAC address 01:23:45:67:89:ab
d9 0104 50 20010db885a3000000008a2e03707334 --> IPv6 address 2001:db8:85a3::8a2e:370:7334
===
TBD for F4..FB choice depends on how address space will be designed for
interoperability with IPv4 and IPv6... from CBOR and compactness PoV, tags
are better, but for end nodes, it's better to have just one stack
implementation with connects to addrs like .4.1.2.3.4 for IPv4 1.2.3.4 or to
.6:2001:db8:85a3:0:0:8a2e:370:7334 for IPv6 (leading dot or colon selects
decimal or hexadecimal in human representation)
- they still will have to implement it in DNS (at least A and AAAA), so may be
  provide tagged versions as "shortcut form" ? with rules like "it must be
  last element of address"


2.3.2. Fragment Descriptor.

   In case packet is fragmented, FrL defines length of Fragment Descriptor of
   the following format:

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Identification        |       Fragment Offset     |R|M|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   .  Copy of first fragment payload's first 0, 1, 2 or 3 words    .
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

TODO put FrL somewhere in fixed part TBD or maybe MF here and
     Frg=unfrag/first/nonfirst-1-word/nonfirsr-2-word in fixed part

TBD 18.09.24 using FrL=1 can't be indicator "first fragment, next bytes are
payload start" because large Options part may also be present; DF must also be
in main header because it may be unfragmented datagram with no descriptor to
look for flags - and also there must be preferred copy size (1 or 2 words) if
fragmentation is allowed (DF=0... so ternary?)
- problem: length ternary here, ternary there... may be fix length to 1 word?
  as L4 ports usually 4 bytes, later variable fields
  - no, SCTP also have 8 bytes, and muSCTP tunnels probably should be fixed
    moving ConnectionTag to first 4 bytes changing TSL to Ver/Init
-> so Frg and FrL:
   * FrL as "DF or preferred copy length or, if Frg>0, actual copy length"
   * Frg: unfrag, nonfirst frag, first without copy (payload reachable), and
     first with copy e.g. too long Options Part which is also fragmented
     (two bits: First, Copy present)
   * for first frag, 16 bits of total length after reassembly
   * for later frags, MF, Resereved bit and Fragment Offset
   * there MUST be full FrL of payload available: e.g. if options and MTU is
     such that FrL requested 3 but only 1 word of payload is left, then
     options part is also split so that first frag will have desired copy;
     packets which does not meet this criteria MUST be discarded as invalid
     due to security concerns

-- variant 26.11.24 two sizes - small and large for new transport protocols?

L - for large size / L4 controlled

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |S|M|       Fragment Offset     |         Identification        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   .  Copy of first fragment payload's first 0, 1, 2 or 3 words    .
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |1|R|IWL|D|M|Hi |                  Fragment Offset              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   .                  Identification, IWL+1 words                  .
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   . Copy of first fragment payload's first 0, 1, 2 or 3 (D)words  .
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   IWL - how many words in Identification, which is completely set by L4
   protocol

   D - copy of payload is measured in double words (8 byte units)

   M - more fragments follow

   Hi - with Fragment Offset forms Total Length if this is very first fragment
   (by Frg)

XXX with dwords it may be up to 44 bytes, leaving only 16 for balancer - do we
need it? IWL for Identification controlled by L4 is extension by itself

TBD why length only in first fragment? repeat it in every, for both
possibility of ICMP "too large" on any frag and like "Jumbogram" IPv6 length?
- or do this length in every-fragment "Jumbo Length" short option?

TBD 27.11.24 huh, what to do with unfragmented (yet) packets, especially when
Identification is L4-controlled? then it must *always* present as intermediate
router don't know what to put into Identification (which is possible when it's
just 16 bit auxiliary field)... so Jumbograms can exist in only fragmented
form? and goal was for like TCP-3 but generic when routers don't have to parse
every protocol (TCP-3 has BOS and EOS flags in addition to BOL and EOL)

TBD night to 30.11: instead of IWL and dwords, simply give 3 bits to FrL and
move that information there, instead of Identification, if L4 protocol wants
so; however, this:
- leaves less than half space to L3.5: 15 words minus (7+1+1) = only 24 bytes
- solvable if FrL is total including offset/id: even better for Jumbo bit
  format parsing, but unbeautiful that in non-DF case it now does not match
  number of words to copy
  - 04.12.24 let's FrL be still words to copy, but preceding is always one
    word: that is, no separate Identification in Jumbo case, assuming this
    will be used by protocols knowing what they do (having unique Packet Id in
    first at most 28 bytes)

-- /variant 26.11.24


TODO

2.3.3. Options.

   Options in IPnh HCver=0 have two formats: short options and long option
   blocks. In short options, a single byte describes both option kind and
   option length, and all short options MUST be supported by every IPnh
   implementation.

       0   1   2   3   4   5   6   7
     +---------------+---------------+
     |               |               |
     |  Option Kind  | Option Length |   1 byte
     |               |               |
     +---------------+---------------+
     \                               \
     /                               /
     \                               \
     /         Option Value          /   0 to 13 bytes
     \                               \
     /                               /
     \                               \
     +-------------------------------+

   Short options are distinguished by having their kind (most significant
   nibble) value less than 14 (0xE), so long options are started by
   high-bits-set pattern.

   Note that short options and long option numbers share the same number
   space (short options implicitly have class with all 0 bits), so that, for
   example, NOP padding option may appear in long options, too.

   Long options MUST be aligned to word boundary and are describing several
   options at once. The rationale behind this is the same as returning from
   IPv6's multiple headers to "header lengths + options" scheme: it's more
   performant for parser to have all needed information at once in single
   cache line of expensive wire-speed cache, to lookup only interesting
   option, than to load several cache lines iterating all options only to find
   that most of them will be skipped.

   Long options are consisting from header, in integral number of double
   words, and then all concatenated corresponfing option values and padding
   bytes after values, if any. Each double word (64 bits) in header starts
   from 3 bits set to 1, then single bit flag - set if this double word in
   this long option block is last, and then three 20-bit option headers:

    0         1         2         3         4         5         6  6
    0 2 4 6 8 0 2 4 6 8 0 2 4 6 8 0 2 4 6 8 0 2 4 6 8 0 2 4 6 8 0  3
   +----------------------------------------------------------------+
   |111L|  Option header 1  |  Option header 2  |  Option header 3  |
   +----------------------------------------------------------------+
   |1110|  Option header 2  |  Option header 3  |  Option header 4  |
   +----------------------------------------------------------------+
   .                                                                .
   +----------------------------------------------------------------+
   |1111| Option header N-2 | Option header N-1 |  Option header N  |
   +----------------------------------------------------------------+
   \                                                                \
   /                   Option values and paddings                   /
   \                                                                \
   +----------------------------------------------------------------+

   Note that this is possible (e.g. after filling 64-byte cache line with
   headers for 24 options) for a packet to have more than one long option
   block. Then, after end of current block, determined by sum of all it's
   lengths and paddings, it is possible to have again some short options or
   new long option block.

    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Mnd|Pad|C|Option number| Option length |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

     Mnd - whether it's mandatory to support or skip and/or report
TBD define like in SCTP or CoAP or IPv6 [RFC 8200] rethink 10 & 11 about multicast

     C - whether this option's value may change in transit (for
     Authentication, like in IPv6 [RFC 8200])

     Option length - value length in bytes

     Pad - pad after option value, in bytes
TBD 20.12.24 05:30 it may be "align to this power of two"

     (subfields are in order allowing more easily manually decode them
     visually observing in hexdump)

   Unused space is simply set to all zeroes - effectively being zero-padding
   options. If some option requires more than word alignment, so that Pad must
   be more than 3 bytes - again, option 0 with proper length may be used.

2.3.3.1. No-op (padding) option - number 0.

   MAY have zero length. Contents is not processed, effectively used as padding.
   Note that there is no "End of Option List" in IPnh HCver=0 - as padding
   option can have non-zero length, it is used in such case, padding till end
   of option area.

2.3.3.2. Attribution option - number 1.

   Used for options which are inserted by transit routers, in contrast to
   originating node - to distinguish which options belong to whom. Contents is
   absolute IPnh address of inserting node, in usual HCver=0 encoding. This
   option MUST have non-zero length and MUST have syntactically valid address
   as value. There MAY be more than one option of this kind in each option
   area of packet.

   The operation is as follows: from the beginning of processed option area
   (Hop by Hop or End to End), options are from node which created original
   packet. After each Attribution option, options following it were inserted
   in transit by system with specified address.

TODO 16.11.24 by https://www.ietf.org/archive/id/draft-herbert-6man-eh-attrib-03.txt

TODO mapping of options to generic CBOR - e.g. attribution with following it
is nested array/map

2.3.3.3. Checksum option - number 2.

   Contains checksum, CRC32 or other checking value (may be even cryptographic
   hash), together with coverage and other information needed for calculation.
   This option's value MUST be aligned to word boundary. Bytes included to
   calculation are words before, bytes with information and then bytes after
   checksum value, subject to lengths. That is, bytes where checksum value
   will be placed are not participating, instead of pretending being zero.
TBD or zeroing value will be faster to calc?

   If checksum option is present in packet, then it MUST be verified by
   receiver and packet silently discarded if corruption was found.

   Version with 2-byte checksum:

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |E|Algo |CsCovBefore|CsCovAfter |       Checksum, 2 bytes       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Version with 4-byte CRC32c:

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |E|Algo |CsCovBefore|CsCovAfter |     Unused, MUST be zero      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        CRC32c Checksum                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   E - extended information (more than 2 bytes), reserved for future use

   Algo - checksum's algorithm
   0 - traditional Internet Checksum
   1 - CRC32c as in iSCSI and SCTP
   2 - SipHash-2-4-64 TBD
TODO

   CsCovBefore - coverage, in words, of bytes before this option. Have no
   special values, that is, zero means zero words.

   CsCovAfter - coverage, in words, of bytes after this option's value. Zero
   value is special (like '*' wildcard), meaning "everything up to and
   including upper boundary"
TBD what is for E2E and payload?

   Handling differs for Hop by Hop and End to End option parts. For End to End
   options, there is logically nothing before start of this area, as packet
   may have been fragmented and different fragments may have gor something
   different in their initial headers in transit. So CsCovBefore MUST NOT be
   going before start of End to End options area. Also, it is possible by this
   option to have some bytes of payload to be covered by checksum. The
   opposite holds for Hop by Hop options - here, CsCovAfter MUST NOT cover
   anything after end of Fragment descriptor, as if nothing exists there.
TBD may be relax this for early fragment detection/retransmit?

   Note that this is possible to have multiple instances of checksum option
   per option area, in which case they SHOULD NOT overlap - for possibility
   for (inserting) transit system to not recalculate regions they don't need
   to (or even nothing at all).

TODO

TODO

2.4. CBOR Header: HCver=0xC.

   This is almost full "everything in CBOR" version, except of fields which
   can't be expressed in CBOR - e.g. length, checksum and fragmenting of CBOR
   itself. Unfortunately, this means that fragmentation must be Hop-by-Hop,
   as in NDN: that is, fragments don't travel network but are reassembled by
   each next hop, and each hop refragments packet when forwarding it to next
   link (given that's link MTU). While this scheme certainly has benefits as
   described in [NDN-FRAG], it also has drawbacks. Thus, an attempt was made
   to put a little more non-CBOR fields - that is, use Next Hop from
   traditional format to make it possible for reasembly/refragmening on just
   some (presumable border) routers, not all of them. This also means presence
   of Traffic Class / Flow Label for them, where, again, Flow Label is a part
   of fragment identifier.

TODO 17.11.24 these should be moved back from binary to CBOR again, because
this defeats the whole purpose of universal format instead of customary
binary. What should be moved out of CBOR to binary is - authenticated parts,
that is, IPv6 in [RFC 8200] defined "chg" flag for options - what could be
changed in transit so that Authentication Header will not include them to not
fail. Thus, there should be multiple CBOR chunks, possibly "mounted" into
main? Also, while here, compression should be made from single entry to
(possibly empty) stack

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Version|  IHL  | HCver |Frg|CWL| Initial/Frag Header Checksum  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Reserved | NHL |                  Total Length                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   .   Next Hop / Forward Route Identifier - optional, NHL words   .
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Coloring word                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   \                                                               \
   /               Fragment Descriptor, if fragmented              /
   \                                                               \
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   \                                                               \
   /             Either Fragment or Unfragmented part              /
   \                                                               \
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Also, to reduce size, some form of generic CBOR compression (not
   specialized to IP), where some of such compressors may make benefit of
   using some "dictionary", either in zlib style or by well known
   IANA-established means.

TBD 27.05.25 what about starting from 0xCA as raw CBAPT-compressed CBOR? and
starting from 0xD* also - as a generic CBOR tag start

TBD

2.4.1. Unfragmented part.


    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Compr Method Id|Reservd|     CBOR Header Length                |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     CBOR Header Checksum                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      CBOR Dictionary ID                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   \                                                               \
   /                         CBOR Header                           /
   \                                                               \
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   \                                                               \
   /                           Payload                             /
   \                                                               \
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

2.4.2. Fragment Descriptor.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Identification                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                Fragment Offset or Total Length                |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

TBD




TBD

IPv4 header for reference:
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Version|  IHL  |Type of Service|          Total Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Identification        |Flags|      Fragment Offset    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Time to Live |    Protocol   |         Header Checksum       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Source Address                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Destination Address                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

