   !!! early draft!

      CBAR: CBOR and generic BLOBs by-Atom Reducing
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1.


1.1. Terminology

   Nibble - half of byte, 4 bits, one hexadecimal digit.

   Sextet - 6 bits, digit of 64-ary numeral system

2. VarNibble.

   This is a variable-length integer encoding on the sub-byte resolution. It
   occupies integral number of nibbles and utilizes addition scheme in
   a manner similar to CoAP [RFC 7252] option delta encoding: the lowest
   possible values are encoded as themselves, and at each increasing of length
   value zero of expanded bitfield is total 

   Enconding                                               Total values / zero
                                                           of next level's
      0                                                    Biased Value
      0 1 2 3
     +-+-+-+-+
     | 0..9  | Integers from 0 to 9, themselves
     +-+-+-+-+

      0               
      0 1 2 3 4 5 6 7 
     +-+-+-+-+-+-+-+-+
     |  0xa  |B.Val. | Integer Values from 10 to 25            10 + 16 = 26
     +-+-+-+-+-+-+-+-+

      0
      0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+
     |  0xb  | Biased Value  | Integer Values from 26 to 281   26 + 256 = 282
     +-+-+-+-+-+-+-+-+-+-+-+-+

      0                   1
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |  0xc  | Biased Value, 12 bits | ...and so on            282 + 4096
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      0                   1                   
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |  0xd  |     Biased Value, 16 bits     |                 4378 + 65536
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      0                   1                   2
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |  0xe  |         Biased Value, 20 bits         |         69914 + 1048576
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      0                   1                   2
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |  0xf  |             Biased Value, 24 bits             | 1118490 + 2^24
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   For example, integer value 17 is encoded as two nibbles 0xa7, and value 42
   is encoded as three nibbles 0xb14.


2.1. VarNibbles.

   This is array, occupying integral number of bytes, each individual element
   is a VarNible. How possible 4-bit padding is treated by upper layer, e.g.
   in a sequence of delta-encoding last nibble could just 0 (indicating no
   difference from previous value), and other schemes could employ explicit
   count of nibbles, so possible last nibble could be ignored if total number
   is odd.

3. The CBAR encoding.

   CBAR-based protocol defines two dictionaries: one is byte string, virtually
   prepended to output buffer for backreferences (but which is not part of
   output itself), and other dictionary is a set of atoms. In degenerate case
   both dictionaries are empty so that compression is possible only by RLE
   (run-length encoding) and backreferences in the compressed data itself.

   An atom is a byte string (3 bytes or more) which, with it's length, is
   known both to compressor and decompressor under some number. So, when
   decompressor sees instruction "use atom 42", it looks up 42-th entry in
   atom dictionary and substitutes this bytestring to output instead of atom
   number. Atoms are numbered from 0 (zero), and lower atom numbers are
   assumed to be used more often.

3.1. Wire format.

   The CBAR record as input to decompressor consists of integral number of
   bytes, which total length is told to decompressor by upper protocol. CBAR
   is inspired by SQLite Row Format [https://www.sqlite.org/fileformat2.html#record_format]
   but using VarNibbles. CBAR contains a header and a body, in that order, each
   of integral number of bytes. The header is a VarNibbles array, where each
   VarNibble is an instruction (operation code) to decompressor, and body,
   also called content area, contains bytes which are used by append to output
   buffer instructions.

   The header begins with a single VarNibble which determines the total number
   of nibbles in the header. The VarNibble value is the size of the header in
   nibbles including the size VarNibble itself, minus one. If size VarNibble
   is special value zero, this means "decompressed data is empty byte string"
   (in such a case, CBAR record MUST consist of a single byte 0x00, other
   possible values for low nibble are reserved).

   If header ended, but there are still unconsumed bytes in content area,
   all of them are appended to output as if header had implicit last
   instruction "append all bytes of remaining length". This allows to reduce
   overhead of uncompressible data to just 1 single byte of CBAR header.

   Following the size VarNibble are one or more additional VarNibbles, one
   per instruction. These additional VarNibbles are called "serial code"
   numbers and determine the instruction, according to the following chart:

TBD may be low bit in size VarNibble is flag so that next is CRC-24 [RFC 4880]
plus 1118490 (so it always 3 bytes to simplify encoder padding)
-> if such bit, only after some first values, to still allow 1-byte header
  -> instead bit, put RLE a1 instead of CRC if first operation is fxxxxxx?

TBD problem with nibble alignment when generating - moving 4 Mb due to odd len is not fun

       0   1   2   3   4   5   6   7
     +---+---+---+---+---+---+---+---+...
     | 0 |Header Len |Header Area, 7 nibbles max 
     +---+---+---+---+---+---+---+---+...

so for len 0 it is 0x00 byte meaning empty string

for below, off by one, hlen = 0 means one, and:
    if (CRC) hlen += 7
    if (Nxt) hlen += 1

       0   1   2   3   4   5   6   7
     +---+---+---+---+---+---+---+---+=============+==============+
     | 1   0 |CRC|   Header Length   | Header Area | Content Area |
     +---+---+---+---+---+---+---+---+=============+==============+

       0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15
     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+...
     | 1   1 |CRC|Nxt|                 Header Length                 |
     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+...

TBD this is 12 bit, make it another 3rd byte so 11 bit / 19 bit?

TBD why CRC in VarNibble? this is waste of 4 bits

-- variant 2:

0x00 .. 0x09 = empty string or VarNibble - 1 (0..8)

       0   1   2   3   4   5   6   7
     +---+---+---+---+---+---+---+---+...
     | 0 |   Opcode Length + 3   |CRC|
     +---+---+---+---+---+---+---+---+...

       0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15
     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+...
     | 1 |Nxt|CRC|               Opcode Length - 60                  |
     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+...

TBD why CRC at all? caller may use any wanted algorithm

TBD flag "Next" has same problem as header itself - length not yet known at start

-- variant 3:

0x00 .. 0x09 = empty string or VarNibble - 1 (0..8)

       0   1   2   3   4   5   6   7
     +---+---+---+---+---+---+---+---+...
     |  9 < Opcode Length + 8 < 240  | Instruction Area 1 to 116 bytes
     +---+---+---+---+---+---+---+---+...

  249 - 241 nibbles and 12 bits literal length
  250 - 242 nibbles and 8 bits literal length
  251 - 241 nibbles and 20 bits literal length
  252 - 242 nibbles and 16 bits literal length
  253 - 241 nibbles
  254 - 242 nibbles and 24 bits literal length
  255 - 241 nibbles and 28 bits literal length

TBD no, up to 7 nibbles may be when still has to next

       0   1   2   3   4   5   6   7
     +---+---+---+---+---+---+---+---+...
     | 1   1   1   1 | Tail  | Next  | Instruction Area 1 to 116 bytes
     +---+---+---+---+---+---+---+---+...

TBD just size VarNibble at end if next?


RFC 7400 quote:
   +----------+---------------------------------------------+----------+
   | code     | Action                                      | Argument |
   | byte     |                                             |          |
   +----------+---------------------------------------------+----------+
   | 0kkkkkkk | Append k = 0b0kkkkkkk bytes of data in the  | k bytes  |
   |          | bytecode argument (k < 96)                  | of data  |
   |          |                                             |          |
   | 1000nnnn | Append 0b0000nnnn+2 bytes of zeroes         |          |
   |          |                                             |          |
   | 10010000 | stop code (end of compressed data; see      |          |
   |          | Section 3.2)                                |          |
   |          |                                             |          |
   | 101nssss | Set up extended arguments for a             |          |
   |          | backreference: sa += 0b0ssss000,            |          |
   |          | na += 0b0000n000                            |          |
   |          |                                             |          |
   | 11nnnkkk | Backreference: n = na+0b00000nnn+2;         |          |
   |          | s = 0b00000kkk+sa+n; append n bytes from    |          |
   |          | previously output bytes, starting s bytes   |          |
   |          | to the left of the current output pointer;  |          |
   |          | set sa = 0, na = 0                          |          |
   +----------+---------------------------------------------+----------+

TBD ssss nnn kkk widths for backref/args instructions

   Serial Code | Hex  | Action
   ============+======+==============================================
        0      |  0   | Append 0x00
        1      |  1   | Append 0x01
        2      |  2   | Prefix next element with CBOR Major 2 length
        3      |  3   | Prefix next element with CBOR Major 3 length
        4      |  4   | Append 0xf4 (CBOR false)
        5      |  5   | Append 0xf5 (CBOR true)
        6      |  6   | Append 0xf6 (CBOR null)
        7      |  7   | Append 0xff
        8      |  8   | Append 0x20 (CBOR -1)
        9      |  9   | Append 1 content byte
   ------------+------+----------------------------------------------
        10     |  a0  | Append 2 content bytes 
        11     |  a1  | RLE: repeat last output
        12     |  a2  | RLE: repeat last output 2 times
        13     |  a3  | RLE: repeat last output 3 times
        14     |  a4  | RLE: repeat last output 4 times
        15     |  a5  | RLE: repeat last output 5 times
        16     |  a6  | RLE: repeat last output 6 times
        17     |  a7  | RLE: repeat last output 7 times
        18     |  a8  | RLE: repeat last output 8 times
        19     |  a9  | RLE: repeat last output 9 times
        20     |  aa  | Set up extended argument for backreference: na += 16
        21     |  ab  | Set up extended argument for backreference: na += 32
        22     |  ac  | Set up extended argument for backreference: na += 64
        23     |  ad  | Set up extended argument for backreference: na += 128
        24     |  ae  | Set up extended argument for backreference: na += 256
        25     |  af  | Reserved for future use, MUST throw error
   ------------+------+---------------------------------------------
    for N>=26:  R = 0 | Append atom with number M
      if even,        |
         set:   R = 2 | Append M+3 content bytes
    M=(N-26)/4        |
    R=(N-26)%4        |
                      | Backreference: n = na + (B % 16), s = (B / 16) + n,
      if odd,         | append n bytes from previously output bytes,
       set B=(N-26)/2 | starting s bytes to the left of the current
                      | output pointer; set na = 0

TBD

   To illustrate how different operations interact with others (especially
   prefixes and RLE), the following pseudocode defines how decompressor
   funstions use variables:

    append(src, len):
        if (src == NULL)
	    throw decode error
        if (prefix) {
            char prefbuf[9]
            pl = encode_cbor_uint(len)
            prefbuf[0] |= (prefix == 2) ? 0x40 : 0x60

            obuf[optr .. optr+pl-1] = prefbuf[0 .. pl-1]
            optr += pl

            prefix = 0;
       }

       obuf[optr .. optr+len-1] = src[0 .. len-1]
       lastoptr = optr
       lastlen  = len

       optr += len

    append_short(code):
        shorts = {0x00, 0x01, NULL, NULL, 0xf4, 0xf5, 0xf6, 0xff, 0x20}
        append(shorts[code], 1)

    append_content(N):
        append(content[iptr], N)
	iptr += N

TBD include prefix in RLE or not?
    rle(count):
        while (count-- > 0) {
	    obuf[optr .. optr+lastlen-1] = obuf[lastoptr .. last_optr+lastlen-1]
	    optr += lastlen
	}

    atom(M):
        append(atoms[M][0], length(atoms[M]))

    backreference(s, n):
        n += na + 2
        append(obuf[optr - s - n], n)
	na = 0

TODO


6. Using CBAR inside CBOR.

   CBAR is a building block for other protocols, and some protocols may want
   to augment CBOR decoder with CBAR decompressor. In such case, CBAR is
   contained in a CBOR byte string (Major Type 2) inside a tagged array, and
   from the consumer point of view result of CBAR decompression is "replaces"
   this array. In this array, everything except CBAR bytestring is optional,
   with default values defined by upper layer protocol.

   Instead of directly supplying atoms array (where each atom number is just
   index of string in array) with bytestring dictionary, applications may also
   choose to just refer to some dictionary defined in other place, by
   specifying it's hash for error checking. This is similar to specifying
   CRC-32 / Adler-32 checksum of deflate dictionary in zlib library, or in
   LZ4 frame.

TBD correct CDDL syntax

   CBAR-CBOR = #6.10([atoms, bytedict, CBAR, checksum])  ; Tag 0x0a for "Atom"
             / #6.10(CBAR)    ; binary string - everything other setup earlier

   atomarr = [ + bstr ]

   atoms = atomarr / uint / bstr,    ; atoms array (mb empty) or their hash
   bytedict = bstr / uint,           ; byte dictionary (mb empty) or it's hash
   CBAR = bstr .size (9..),
   ? checksum = uint

TBD may be RFC 6920 ?

TODO

=========== Format with bytes & Pyramint5 instead of VarNibbles =====

   This is a variation of static Huffman encoding of unsigned integer, in
   a "pyramid" way, where first (most wide) is exact value, and each next level
   is in "units" of next power of two after maximal value of previous level. Levels are
   encoded as bit prefixes 0, 10, 110, etc.

   For example, Pyramint5 is

   * 0aaaa - unit is 1, so values 00000 to 01111 are 0..15
   * 10bbb - now unit is 16, 15+1, and bbb=000 means 16, bbb=001 means 32,
             so e.g. overall Pyramint5 value 10001 means 32, and maximal value
	     at this level, bbb=111 and overall Pyramint5 10111 - is 128.
   * 110cc - remember, zero value at next level is next power of two, not just
             one "unit", so cc=00, or overall 11000, is 256 now! Then are 512, 768
	     and maximum - 1024.
   * 1110d - at the last level only one bit it left, so there are just two
             values - 2048 and 4096.
   * 11110 - we also can define this as 8192, though no bits left
   * 11111 - similarly, maximum possible value will be 16384

   Extending one bit, we get Pyramint6 as follows:

   0aaaaa  - 0..31 * unit=1
   10bbbb  - 0..15 * unit=32    -> from 32    to max 512
   110ccc  - 0..7  * unit=1024  -> from 1024  to max 8192
   1110dd  - 0..3  * unit=16384 -> from 16384 to max 65536
   11110e  - 0..1  * unit=128 K -> from 128 K to max 256 K
   111110  - 512 K
   111111  - 1 M

pyramint4:                             1000 1001 1010 1011 1100 1101 1110 1111  
  0    1    2    3    4    5    6    7    8   16   32   64  128  256  512 1024

   additional information values:
   +------------+------------------------------------+----------+
   | 00000nnn  | Append 0b00000nnn+1 bytes of zeroes
   | 00001nnn  | Append 0b00000nnn+1 bytes of 0xff
   | 0x10   16 | Append 0x20 (CBOR int -1)
   | 0x11   17 | Append 0x01 (CBOR int 1)
   | 0x12   18 | Append 0x02 (CBOR int 2)
   | 0x13   19 | Append 0x03 (CBOR int 3)
   | 0x14   20 | Append 0xf4 (CBOR false)
   | 0x15   21 | Append 0xf5 (CBOR true)
   | 0x16   22 | Append 0xf6 (CBOR null)
   | 0x17   23 | Append ??? 
   | 0x18   24 | RLE: repeat last output
   | 0x19   25 | RLE: repeat last output 2 times
   | 0x1a   26 | RLE: repeat last output 4 times
   | 0x1b   27 | RLE: repeat last output 8 times
   | 0x1c   28 | Reserved
   | 0x1d   29 | Reserved
   | 0x1e   30 | Reserved
   | 0x1f   31 | Stop code: append everything what left in literals
   +------------+------------------------------------+----------+

TBD text string can't contain repeated runs of 00/f4/f5/f6/ff !


main bytecodes:
   +-------------------+------------------------------------+----------+
   |                   | 
   | 000kkkkk          | Append k+1 bytes of data in the bytecode argument
   |                   | 
   | 001kkkkk kkkkkkkk | Append k+31 bytes of data in the bytecode argument
   |                   | 
   | 010kkkkk          | Append k+23 bytes of data in the bytecode argument,
   |                   | prefixed with CBOR Major 2 length of k+23 (bstr)
   |                   | 
   | 011kkkkk          | Append k+23 bytes of data in the bytecode argument,
   |                   | prefixed with CBOR Major 3 length of k+23 (tstr)
   |                   | 
   | 100ddddd          | Special values from additional information 
   |                   | 
   | 1010tttt tttttttt | Atom: append content of atom a=aa+0b0tttttttttttt,
   |                   | set aa = 0
   |                   | 
   | 1011iiii          | aa += 4096 * (0b0iiii + 1);
   |                   | 
   |                   | Set up extended arguments for a backreference:
   |                   | 
   | 1100ssss          | sa += 512 * (0b0ssss + 1)
   |                   | 
   | 1101nnnn          | na += 0b0nnnn0000 + 16
   |                   | 
   | 111nnnnk kkkkkkkk | Backreference: n = na+0b0000nnnn+2;
   |                   | s = k+sa+n; append n bytes from
   |                   | previously output bytes, starting s bytes
   |                   | to the left of the current output pointer;
   |                   | set sa = 0, na = 0
   +-------------------+------------------------------------+----------+

perl -E 'use CBOR::XS; sub true {1}; print encode_cbor [
   ["algorithm", "HMAC", "SHA1"] => true,
   ["algorithm", "HMAC", "SipHash", 0, 0] => 2,
   ["algorithm", "HMAC", "SipHash", 0, 1] => 4,
   ["algorithm", "kex"] => [
   				"curve25519-sha256",
				"curve25519-sha256@libssh.org",
				"ecdh-sha2-nistp256",
				"ecdh-sha2-nistp384",
				"ecdh-sha2-nistp521",
				"diffie-hellman-group-exchange-sha256",
				"diffie-hellman-group16-sha512",
				"diffie-hellman-group18-sha512",
				"diffie-hellman-group14-sha256",
				"diffie-hellman-group14-sha1"
			],
   ["algorithm", "key"] => [
				"ssh-rsa",
				"rsa-sha2-512",
				"rsa-sha2-256",
				"ecdsa-sha2-nistp256",
				"ssh-ed25519"
			],
   ["algorithm", "ciphers"] => [
				"chacha20-poly1305@openssh.com",
				"aes128-ctr",
				"aes192-ctr",
				"aes256-ctr",
				"aes128-gcm@openssh.com",
				"aes256-gcm@openssh.com",
				"aes128-cbc",
				"aes192-cbc",
				"aes256-cbc"
			],
   ["assoc", "retrans", "max"] => 3,
   ["dev", "cpu", 0, "temperature"] => 64.1,
]' | hexdump -C
00000000  90 83 49 61 6c 67 6f 72  69 74 68 6d 44 48 4d 41  |..IalgorithmDHMA|
00000010  43 44 53 48 41 31 f5 85  49 61 6c 67 6f 72 69 74  |CDSHA1..Ialgorit|
00000020  68 6d 44 48 4d 41 43 47  53 69 70 48 61 73 68 00  |hmDHMACGSipHash.|
00000030  00 02 85 49 61 6c 67 6f  72 69 74 68 6d 44 48 4d  |...IalgorithmDHM|
00000040  41 43 47 53 69 70 48 61  73 68 00 01 04 82 49 61  |ACGSipHash....Ia|
00000050  6c 67 6f 72 69 74 68 6d  43 6b 65 78 8a 51 63 75  |lgorithmCkex.Qcu|
00000060  72 76 65 32 35 35 31 39  2d 73 68 61 32 35 36 55  |rve25519-sha256U|
00000070  63 75 72 76 65 32 35 35  31 39 2d 73 68 61 32 35  |curve25519-sha25|
00000080  36 2e 6f 72 67 52 65 63  64 68 2d 73 68 61 32 2d  |6.orgRecdh-sha2-|
00000090  6e 69 73 74 70 32 35 36  52 65 63 64 68 2d 73 68  |nistp256Recdh-sh|
000000a0  61 32 2d 6e 69 73 74 70  33 38 34 52 65 63 64 68  |a2-nistp384Recdh|
000000b0  2d 73 68 61 32 2d 6e 69  73 74 70 35 32 31 58 24  |-sha2-nistp521X$|
000000c0  64 69 66 66 69 65 2d 68  65 6c 6c 6d 61 6e 2d 67  |diffie-hellman-g|
000000d0  72 6f 75 70 2d 65 78 63  68 61 6e 67 65 2d 73 68  |roup-exchange-sh|
000000e0  61 32 35 36 58 1d 64 69  66 66 69 65 2d 68 65 6c  |a256X.diffie-hel|
000000f0  6c 6d 61 6e 2d 67 72 6f  75 70 31 36 2d 73 68 61  |lman-group16-sha|
00000100  35 31 32 58 1d 64 69 66  66 69 65 2d 68 65 6c 6c  |512X.diffie-hell|
00000110  6d 61 6e 2d 67 72 6f 75  70 31 38 2d 73 68 61 35  |man-group18-sha5|
00000120  31 32 58 1d 64 69 66 66  69 65 2d 68 65 6c 6c 6d  |12X.diffie-hellm|
00000130  61 6e 2d 67 72 6f 75 70  31 34 2d 73 68 61 32 35  |an-group14-sha25|
00000140  36 58 1b 64 69 66 66 69  65 2d 68 65 6c 6c 6d 61  |6X.diffie-hellma|
00000150  6e 2d 67 72 6f 75 70 31  34 2d 73 68 61 31 82 49  |n-group14-sha1.I|
00000160  61 6c 67 6f 72 69 74 68  6d 43 6b 65 79 85 47 73  |algorithmCkey.Gs|
00000170  73 68 2d 72 73 61 4c 72  73 61 2d 73 68 61 32 2d  |sh-rsaLrsa-sha2-|
00000180  35 31 32 4c 72 73 61 2d  73 68 61 32 2d 32 35 36  |512Lrsa-sha2-256|
00000190  53 65 63 64 73 61 2d 73  68 61 32 2d 6e 69 73 74  |Secdsa-sha2-nist|
000001a0  70 32 35 36 4b 73 73 68  2d 65 64 32 35 35 31 39  |p256Kssh-ed25519|
000001b0  82 49 61 6c 67 6f 72 69  74 68 6d 47 63 69 70 68  |.IalgorithmGciph|
000001c0  65 72 73 89 55 63 68 61  63 68 61 32 30 2d 70 6f  |ers.Uchacha20-po|
000001d0  6c 79 31 33 30 35 2e 63  6f 6d 4a 61 65 73 31 32  |ly1305.comJaes12|
000001e0  38 2d 63 74 72 4a 61 65  73 31 39 32 2d 63 74 72  |8-ctrJaes192-ctr|
000001f0  4a 61 65 73 32 35 36 2d  63 74 72 4e 61 65 73 31  |Jaes256-ctrNaes1|
00000200  32 38 2d 67 63 6d 2e 63  6f 6d 4e 61 65 73 32 35  |28-gcm.comNaes25|
00000210  36 2d 67 63 6d 2e 63 6f  6d 4a 61 65 73 31 32 38  |6-gcm.comJaes128|
00000220  2d 63 62 63 4a 61 65 73  31 39 32 2d 63 62 63 4a  |-cbcJaes192-cbcJ|
00000230  61 65 73 32 35 36 2d 63  62 63 83 45 61 73 73 6f  |aes256-cbc.Easso|
00000240  63 47 72 65 74 72 61 6e  73 43 6d 61 78 03 84 43  |cGretransCmax..C|
00000250  64 65 76 43 63 70 75 00  4b 74 65 6d 70 65 72 61  |devCcpu.Ktempera|
00000260  74 75 72 65 fb 40 50 06  66 66 66 66 66           |ture.@P.fffff|

perl -E 'use CBOR::XS; print encode_cbor [
   [30, 31, 32]		=> \1,              
   [30, 31, 33, 0, 0]	=> 2,
   [30, 31, 33, 0, 1]	=> 4,
   [30, 34]		=> [35, 36, 37, 38, 39, 40, 41, 42, 43, 44],
   [30, 45]		=> [46, 47, 48, 49, 50],
   [30, 51]		=> [52, 53, 54, 55, 56, 57, 58, 59, 60],
   [61, 62, 63]		=> 3,
   [64, 65, 0, 66]	=> 64.1,
]' | hexdump -C
00000000  90 83 18 1e 18 1f 18 20  f5 85 18 1e 18 1f 18 21  |....... .......!|
00000010  00 00 02 85 18 1e 18 1f  18 21 00 01 04 82 18 1e  |.........!......|
00000020  18 22 8a 18 23 18 24 18  25 18 26 18 27 18 28 18  |."..#.$.%.&.'.(.|
00000030  29 18 2a 18 2b 18 2c 82  18 1e 18 2d 85 18 2e 18  |).*.+.,....-....|
00000040  2f 18 30 18 31 18 32 82  18 1e 18 33 89 18 34 18  |/.0.1.2....3..4.|
00000050  35 18 36 18 37 18 38 18  39 18 3a 18 3b 18 3c 83  |5.6.7.8.9.:.;.<.|
00000060  18 3d 18 3e 18 3f 03 84  18 40 18 41 00 18 42 fb  |.=.>.?...@.A..B.|
00000070  40 50 06 66 66 66 66 66                           |@P.fffff|
00000078
perl -E 'use CBOR::XS; use Compress::LZF; print compress_best encode_cbor [
   [30, 31, 32] => Types::Serialiser::true,
   [30, 31, 33, 0, 0] => 2,
   [30, 31, 33, 0, 1] => 4,
   [30, 34] => [35, 36, 37, 38, 39, 40, 41, 42, 43, 44],
   [30, 45] => [46, 47, 48, 49, 50],
   [30, 51] => [52, 53, 54, 55, 56, 57, 58, 59, 60],
   [61, 62, 63] => 3,
   [64, 65, 0, 66] => 64.1,
]' | hd                                                                        
00000000  78/09 90 83 18 1e 18 1f  18 20 f5 85#60 07/03 21  |x........ ..`..!|
00000010  00 00 02#c0 09/02 01 04  82#20 09/15 22 8a 18 23  |......... .."..#|
00000020  18 24 18 25 18 26 18 27  18 28 18 29 18 2a 18 2b  |.$.%.&.'.(.).*.+|
00000030  18 2c#40 19/0b 2d 85 18  2e 18 2f 18 30 18 31 18  |.,@..-..../.0.1.|
00000040  32#40 0f/1f!33 89 18 34  18 35 18 36 18 37 18 38  |2@..3..4.5.6.7.8|
00000050  18 39 18 3a 18 3b 18 3c  83 18 3d 18 3e 18 3f 03  |.9.:.;.<..=.>.?.|
00000060  84 18 40 18/08 41 00 18  42 fb 40 50 06 66#20 00  |..@..A..B.@P.f .|
00000070 /00 66                                             |.f|


TODO


      0  
      0 1 2 3 4 5
     +-+-+-+-+-+-+
     |   0..47   | Integers from 0 to 47, themselves
     +-+-+-+-+-+-+

      0          |    
      0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+
     |1 1 0 0| Biased Value  | Integer Values from 48 to 303  48 + 256 = 304
     +-+-+-+-+-+-+-+-+-+-+-+-+

      0          |        1  |
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |1 1 0 1|       Biased Value        | 304 ... 16687    304 + 2^14 = 16688
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      0          |        1  |           |    2
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |1 1 1 0| Value as is (for simplicity), 20 bits |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      0          |        1  |           |    2      |
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |1 1 1 1|       Value as is (for simplicity), 26 bits       |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


Header Opcode Length:

    0x00 - empty string

      0               
      0 1 2 3 4 5 6 7 
     +-+-+-+-+-+-+-+-+
     |    1 .. 48    | Single Sextet 0 .. 47
     +-+-+-+-+-+-+-+-+

      0               
      0 1 2 3 4 5 6 7 
     +-+-+-+-+-+-+-+-+
     |   49 .. 127   | Number of sextets, 2 .. 80
     +-+-+-+-+-+-+-+-+

      0                   1
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |1 0|Number of sextets, 14 bits |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


      0                   1                   2
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |1 1|        Number of sextets, 22 bits         |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Serial Code | Action
   ============+==============================================
       0..3    | Append 1..4 times 0x00
       4..7    | Append 1..4 times 0xff
         8     | Prefix next element with CBOR Major 2 length
         9     | Prefix next element with CBOR Major 3 length
        10     | Set up extended argument for backreference: na += 16
        11     | Set up extended argument for backreference: na += 32
        12     | Set up extended argument for backreference: na += 64
        13     | Set up extended argument for backreference: na += 128
        14     | Set up extended argument for backreference: na += 256
   | 0x09   15 | Append 0x21 (CBOR int -2)
   | 0x10   16 | Append 0x20 (CBOR int -1)
   | 0x11   17 | Append 0x01 (CBOR int 1)
   | 0x12   18 | Append 0x02 (CBOR int 2)
   | 0x13   19 | Append 0x03 (CBOR int 3)
   | 0x14   20 | Append 0xf4 (CBOR false)
   | 0x15   21 | Append 0xf5 (CBOR true)
   | 0x16   22 | Append 0xf6 (CBOR null)
   | 0x17   23 | Append 0x2c (comma, CBOR -13, SSH list separator) 
   | 0x18   24 | RLE: repeat last output
   | 0x19   25 | RLE: repeat last output 2 times
   ------------+---------------------------------------------
    for N>=26:  R = 0 | Append atom with number M
      if even,        |
         set:   R = 2 | Append M+1 content bytes
    M=(N-26)/4        |
    R=(N-26)%4        |
                      | Backreference: n = na + (B % 16), s = (B / 16) + n,
      if odd,         | append n bytes from previously output bytes,
       set B=(N-26)/2 | starting s bytes to the left of the current
                      | output pointer; set na = 0


TODO

=========== Format with VarInt15 instead of VarNibbles =====

as in bytes, no header area
..or VarInt22 ? or make it not int but just short/mid/long


      0               
      0 1 2 3 4 5 6 7 
     +-+-+-+-+-+-+-+-+
     |0| Short codes | 
     +-+-+-+-+-+-+-+-+

      0                   1
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |1|0 0 0|Atom number, 0 .. 4095 |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      0                   1
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |1|Len-1|Backreference offset-1 | non-zero 3 bits, that is, 0x9..0xe
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      0                   1                   2
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |1|1 1 1|Backreference offset-1 |  Length - 9   |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   +----------+----------------------------------------------+----------+
   |  short   | Action                                       | Argument |
   |  code    |                                              |          |
   +----------+----------------------------------------------+----------+
   | 0kkkkkkk | Append k = 0b0kkkkkkk + 1 bytes of data in   | k bytes  |
   |          | the bytecode argument; k <= 80               | of data  |
   |          |                                              |          |
   | 0101kkkk | Append k = 0b0kkkk bytes of data in the      | k bytes  |
   |          | bytecode argument, prefixed with their       | of data  |
   |          | length in CBOR Major Type 2 (k+1 total);     |          |
   |          | that is, first byte is 0x4k                  |          |
   |          |                                              |          |
   | 011rrvvv | Append n = 0b0rr + 1 identical bytes with    |          |
   |          | value from table below; n is 1, 2 or 3 so    |          |
   |          | rr is 0b000 to 0b010                         |          |
   |          |                                              |          |
   | 01111011 | Append byte 0xd6 (Tag cbor-packed)           |          |
   |          |                                              |          |
   | 01111100 | Append byte 0x2c (ASCII comma "," which is   |          |
   |          | list separator in SSH)                       |          |
   |          |                                              |          |
   | 01111101 | Append two bytes 0xd8 0x19 (Tag stringref)   |          |
   |          |                                              |          |
   | 0111111a | stop code - end of compressed data;          |          |
   |          | if a=0 then add all remaining literal bytes  |          |
   |          | if a=1 then just stop                        |          |
   +----------+----------------------------------------------+----------+


   vvv | Byte  | Commentary 
   ====+=======+==========================
    0  | 0x00  | CBOR Integer 0
    1  | 0x01  | CBOR Integer 1
    2  | 0x02  | CBOR Integer 2
    3  | 0x20  | CBOR Integer -1
    4  | 0xf4  | CBOR false
    5  | 0xf5  | CBOR true
    6  | 0xf6  | CBOR null
    7  | 0xff  | also commonly occurs repeated
    
   An uncompressed length before CBAR raw stream is encoded as single UTF-8
   character as it was in [RFC 2279], that is, allowing values up to 2^31-1
   in six bytes. Length 0 means that no compression was achieved, so remaining
   data should be copied to output buffer as is, without applying
   decompression. Stop codes allow to add data such as a checksum at end of
   stream. If such checksum, or CRC, or hash, is used, then it MUST cover
   uncompressed data. If space constraints are serious, but 16-bit
   checksums/CRCs are considered weak, then CRC-24 [RFC 4880] could be
   recommended.

TODO

=========== Two-pass Format: LZF + Atoms =====

   External format: use Compress::LZF as is

   Internal pass: for CBOR, use unused codes 28..30 in each Major Type. For
   integers, it's shorter one (e.g. 3-byte), for each string type, prefix it
   with atom length as prescribed by CBOR, for tags, put common like
   stringref, and in special, make generic escape mechanism:

   e.g. 0xfc to escape one byte
   0xfd - extended escape, and e.g. for atoms in middle of strings

TBD what extended escapes?

TBD if 3 codes in each type, are 768 atoms enough? may reuse from map/array,
but isn't just 1535 коряво?

TODO what should be internal pass for non-CBOR but just SSH blob?
and need some another format for uncompressed length prefix

TBD if literal in CBOR, then this means unsupported so switching back to CBOR
cannot be reliable?

so:
  FC - copy 2+ bytes literal
  FD - dispense (decompress) atom
  FE - escape a single byte

and all 0xFx codes switch off CBOR going to BLOB mode

TBD is VarInt15 enough for atom number and FC length and in byte strings?

need we preserve indefinite-length strings with atoms inside? probably yes,
ULP may have crypto etc.

TBD may be simply wait for draft-cbor-packed to settle instead of "atom
surrounded in string"?

 |  Taking into account the encoding of these referring data items, there
 |  are 16 one-byte references, 48 two-byte references, 512 three-byte
 |  references, 131072 four-byte references, etc.  As CBOR integers can
 |  grow to very large (or very negative) values, there is no practical
 |  limit to how many shared items might be used in a Packed CBOR item.

TBD cbor-packed is less effective in Tag 6, however, what if replace unused codes
with Tag 6, e.g. 0x5C A0 being equivalent to d6 18 a0 ?

huh, the task of several atoms in a bytestring is almost equivalent to non-CBOR BLOB

possible solution:
  * for BLOB media type, initialize "remaining_bytes" to entire length, and go
    to INBLOB state
  * in CBOR state every opcode is allowed, and special one for strings emits
    CBOR string prefix, then sets remaining_bytes to string's length
  * in BLOB state, only FC/FD/FE allowed, any other MUST throw error, and
    decrement remaining_bytes for every emitted piece
  * when remaining_bytes becomes zero, go back to CBOR state

so, for strings:

  5C - 2+ byte length (varint) BLOB state inside
  5D - decompress one atom
  5E - single byte length BLOB state inside

and same for UTF-8 text strings (7C/7D/7E)

TBD what if use simple(0)..simple(15) for first atoms? so mb change varint to 240
- that may substitute CBOR fragment as-is, so requires stricter typing in atom
  setup, that is, InternAtom/GetAtomName/ReleaseAtom
  - use VarNibbles record format there? differentiate CBAR and CBAP?

=== 15.12.24:

      CBAR: CBOR and generic BLOBs by-Atom Reducing
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

packing of CBOR sequences - cbor-packed not, CBAR allows

pre-setup - possible e.g. as CBOR sequence
TBD use 22098 for recursive "after unpacking, there are more CBAR inside"?
TBD alternatives (tag 121) for multiple dictionaries?

alternative to YANG SID (avoid uniqueness management) and YANG bits (#6.43)
and CBOR-LD (may be even JSON-LD)

  The format is described in terms of unpacker copying data from input to
  target unpacked CBOR which later can be feed to generic CBOR decoder,
  however, it is possible, though hard, to implement in-place access to
  CBAR data (like in draft-cbor-packed), if application wish so and is
  constrained in RAM but not ROM.
strings are typically already in implementation memory, opposed to bytedict

   CBAR-CBOR = #6.10([atoms, bytedict, CBAR, ? checksum])  ; 0x0a for "Atom"
             / #6.10(CBAR)    ; binary string - everything other setup earlier

   atomarr = [ + atom ]       ; "atom" is like in X11 sense - number of string
   atom = bstr                ; raw value
        / #6.10(bstr)         ; itself CBAR - definition uses previous atoms
	/ any                 ; valid CBOR fragment to substitute

   atoms = atomarr / map / uint / bstr, ; atoms array (mb empty) or their hash
   bytedict = bstr / uint,           ; byte dictionary (mb empty) or it's hash
   CBAR = null / bstr .size (3..),   ; may have e.g. 40003 tag if DEFLATE'd
   checksum = uint

  In atom definitions, each definition MUST use only prior atom numbers if
  it's CBAR itself (that is, defined with #6.10 tag).

  ## Model of operation.

  Encoder and decoder are described here in object-oriented terms, though
  implementation is not obliged to be OO-style. At some point, new object is
  instantiated (constructor called), on which methods could be called, either
  for settings (e.g. canonical mode) or for actual CBOR processing. From this
  specification's point of view, a decoder object holds state needed for
  unpacking, that is, primarily dictionaries of atoms. This state could be
  modified by application calling methods on object, outside of any CBOR
  processing, and thus CBAR information is defined in such way that is
  equivalent to "in-band" calling of such state-modifying methods.

  A generalized view of application protocol is ordered sequence of messages
  decoded (or a sub-sequence if partial ordered):

   new()       Message 1                   Message 2
     |      .-------------.     .----------------------------.
     |      | CBOR Item 1 |     |        CBOR Sequence       |
     |      |             |     |-------------+--------------|
     |      |             |     | CBOR Item 1 | CBOR Item 2  |
     |----->|             |---->|             |              |----> ...
     |      |             |     |             | {      lvl 1 |
     |      |             |     |             |   [    lvl 2 |
     |      |             |     |             |     {  lvl 3 |
     |      |             |     |             |     },       |
     |      |             |     |             |     s, lvl 2 |
            `-------------'     `-------------+--------------'

  However, observe that generic decoder does not need to know application
  messages' boundaries - to support CBOR Sequences, it is enough for decoder
  to have methods e.g. `decode()` and `decode_prefix()` both accepting buffer
  with bytes (e.g. pointer and length), where former method expects entire
  buffer consists of complete CBOR item and latter decodes complete CBOR item
  returning number of bytes consumed from buffer (note such interface is
  unified for both CBOR Sequences and incremental parsing of partially
  received stream).

  Thus, for decoder the diagram above is in fact equivalent to single message
  with three CBOR sequences or 3 messages - it's merely for application where
  it may call additional methods after the initial `new()` constructor and
  settings methods.

  CBAR is intended to be used in scenarios where packing information is known
  beforehand, so it is possible to achieve better compression by not including
  dictionary in each CBOR message, but provide it out of band. Of course, full
  support of inline (in CBOR stream itself) dictionaries definition is
  supported, as well as multiple dictionaries and redefining them inside of
  complex CBOR structures - similar in spirit to JSON-LD's "@context"'s. On
  the diagram above there is map containg array containing other map and
  string, elements of outer map wuld have level 1 of nesting, elements of
  array are on level 2 (including string s), and elements in map in array
  would be on level 3. Thus, each top-level CBOR item could be viewed as being
  on level 0.
 
  ## Tag equivalence

  This section borrows same chapter from [draft-cbor-packed] and extends it
  for CBAR in adding exceptions to generic rule for nested tags where it was
  equivalent to leave outer tag and replace inner tag with it's
  modified/substituted contents: for Tag #6.10, a tag following it (that is,
  inner to it) may be "modifier" to it. For example,

    #6.10(#6.63("binary string"))

  means that binary string after unpacking (with dictionary set up somewhere
  before) must be "substituted", omitting both tags, as CBOR elements in this
  place. If that binary string is to be left as is for application in unpacked
  CBOR, then just `#6.10("binary string")` is used. If application wants
  a binary string, just tagged as CBOR Sequence, then tag is moved out:

    #6.63(#6.10("binary string")

  This way, tag #6.10 could be used just for binary strings unpacking, not
  altering CBOR tree structure at all - hence "B" in "CBAR" is for generic
  BLOBs. And both methods could be combined in same CBOR stream.

  ## Rules of Tag #6.10 substituitions

  Example of substituting bare tag #6.10 for binary strings already was given
  (only to remind here is that inner tag 24 also could be used for complete
  CBOR item, not sequence). Tag #6.10 on an array where CBAR member is
  non-null is always expanded as complete CBOR item (unless CBAR member has
  tag #6.63 on it, then as sequence) - because it is useless to setup
  dictionary for just one binary string, so it's not supported.

TBD is it?

  The other possible application of Tag #6.10 is on integers, where integer is
  atom number, expanding to a single string, with positive integers expanding
  to binary strings (Major Type 2) and negative to text strings (Major Type
  3) TBD mnemonic is to add 2 to major type, but is it friendly?

  This is in fact just another way to write #6.10(#6.24(h'7C /atom num/') or
  with "5C" for binary string, saving a byte for atom numbers less than 65536
  and having additional benefits:

  * simplified encoders/decoders may operate on single atoms rather than deep
    scanning of strings concatenated from pieces
  * a tag with a number is more readable in Diagnostic Notation than binary
    string with a prefix and varint

  And last use of Tag #6.10 is on undefined as map key (that is, two bytes
  0xDA 0xF7), where map's value for such key is array for dictionary setup
  (that is, in which CBAR member is null). It is described later in section
  on nesting decitionaries.

  All other uses of Tag #6.10 are reserved for future use and MUST NOT be
  emitted by conforming encoders for now version.

  ## Dictionary setup - tag #6.10 on array

  Tag #6.10 always sets up dictionary for use later in stream. It may have
  CBAR member (last or before checksum), which is then expanded using this
  dictionary and substituted in place of entire tagged array - or CBAR member
  may be null, meaning this is just dictionary setup for later use (e.g. on
  individual bytestrings or integers, see examples above). In any case, tagged
  array is "cutted" from unpacked CBOR, as if were not existing - thus
  preferred place for dictionary is at top-level CBOR Sequence (level 0 on the
  messages diagram above).

  Dictionary setup can be in two forms: simple and full. Simple is:

    #6.10([atoms, bytedict, CBAR, ? checksum])

  Where `atoms` is array explicitly assigning atom in dictionary by index in
  array - first, i.e. index 0 is array, is atom 0, then atom 1 and so on.

  Full form instead of `atoms` array and `bytedict`  consists of commands and
  their arguments, occuping everything till CBAR (and possibly checksum)
  members. Commands (opcodes) are single-character strings which have single
  outer array member after them - also an array if more than one argument
  needed. That is, it is like a key-value list (like map), but in array form,
  may have odd number and is processed sequentially.

  Rationale: naturally, it could have been a map, but map could have entries
             in any order, so it would require from decoder to 1) buffer
	     everything till end of map is seen and start processing only
	     then, and 2) some way to reference between map entries, when
	     there is more than one operation of same type (that is, requiring
	     array under a single map key). Thus, in array form it is possible
	     for decoder to process entries immediately as they are seen,
	     simplifying implementation and lowering memory requirements,
	     while also allowing variable number of parameters per operation.

  Full form at last produces an (in-memory) array of strings, which is then
  processed same as array in simple form. Thus, first simple form and overall
  CBAR decoder operation will be described, and then full form in later
  section.

  # Details of CBAR operation and simple-form dictionary

  VarUInt30 means variable-length unsigned integer capable of holding at
  most 30 bits, by the following bit patterns (from MSB to LSB):
  * 0aaaaaaa                             - 7 bits, values 0..127 coded as-is
  * 100aaaaa bbbbbbbb                    - 13 bits
  * 101aaaaa bbbbbbbb cccccccc           - 21 bits
  * 11aaaaaa bbbbbbbb cccccccc dddddddd  - 30 bits

  Rationale: As this compression is targeted primarily towards constrained
             implementations, those supporting more than 32 bits are
             considered unconstrained - that is, e.g. more than 4 Gbytes
             chunks of data. And 2^30 atoms will require 5 Gbytes of memory at
             minimum; for literal lengths 2^30 bytes is also unlikely to
             surpass when other memory from 4 Gbytes is needed for other
             purposes.

             However, if discussion will conclude that 60+ bits needed (e.g.
             for unification with YANG SID), alternative VarUInt60 supporting
	     60 bits in 8 bytes is posible:

             0..143 values coded as themselves                    bits:
             1001aaaa bbbbbbbb                                     - 12
             1010aaaa bbbbbbbb cccccccc                            - 20
             1011aaaa bbbbbbbb cccccccc dddddddd                   - 28
             1100aaaa bbbbbbbb cccccccc dddddddd eeeeeeee          - 36
             1101aaaa bbbbbbbb cccccccc dddddddd eeeeeee  ffffffff - 44
             1110aaaa bbbbbbbb cccccccc dddddddd   ...    gggggggg - 52
             1111aaaa bbbbbbbb cccccccc dddddddd   ...    hhhhhhhh - 60

             Or even full 64 bits in 9 bytes is possible:

             0..191 values coded as themselves                     bits:
             110aaaaa bbbbbbbb                                     - 13
             1110aaaa bbbbbbbb cccccccc                            - 20
             11110aaa bbbbbbbb cccccccc dddddddd                   - 27
             111110aa bbbbbbbb cccccccc dddddddd eeeeeeee          - 34
             11111100 aaaaaaaa bbbbbbbb cccccccc dddddddd eeeeeeee - 40
             11111101 aaaaaaaa bbbbbbbb cccccccc   ...    ffffffff - 48
             11111110 aaaaaaaa bbbbbbbb cccccccc   ...    gggggggg - 56
             11111111 aaaaaaaa bbbbbbbb cccccccc   ...    hhhhhhhh - 64

  Opcodes of IN_BLOB state, with possible <argument N>:

  C0             - Atom 0
  C1             - Atom 1
  F5             - Atom 2
  F6             - Atom 3
  F7             - Atom 4
  F8             - Atom 5
  F9             - Atom 6
  FA             - Atom 7
  FB             - Atom 8
  FC <VarUInt30> - Copy N Literal bytes, N MUST be greater than 1
  FD <VarUInt30> - Decompress (dispense) atom N
  FE             - Escape next byte (Copy 1 literal byte)
  FF             - Copy remaining_bytes literal bytes
  any other byte - Output this byte

  Any output operation decrements `remaining_bytes` variable by the size of
  chunk output, and in well-formed input it MUST not became less than zero.
  If `remaining_bytes` became zero (0), state is changed to IN_CBOR.

  Rationale: UTF-8 since updated RFC can't encode codepoints higher than
             0x10FFFF, thus bytes higher than 0xF5 can't appear in well-fromed
	     UTF-8, and 0xC0 and 0xC1 also must not appear in conforming
	     UTF-8, thus these bytes could be used inside CBOR Major Type 3
	     (string) without escaping, as atoms often will be part of text
	     strings, not only binary. For applications wanting to trade-off
	     performance to compression ratio, every other byte means itself
	     which allows to scan contents of text string byte-by-byte, saving
	     few bytes - instead, for performance of decoder, FC code with
	     length should be used, allowing to skip to next code.

  Opcodes of IN_CBOR state, with <arguments> (and mnemonics):

  1C <3 bytes>   - (terCio) Output 1A 00 <3 bytes>
  1D             - Atom 0
  1E             - Atom 1
  1F <5 bytes>   - (Five) Output 1B 00 00 00 <5 bytes>
  3C <3 bytes>   - (terCio) Output 3A 00 <3 bytes>
  3D             - Atom 2
  3E             - Atom 3
  3F <5 bytes>   - Five-integer: Output 3B 00 00 00 <5 bytes>
  5C <VarUInt30> - Convert atom N to binary string
  5D             - Atom 4
  5E             - Atom 5
  7C <VarUInt30> - Convert atom N to text string
  7D             - Atom 6
  7E             - Atom 7
  9C             - Atom 8
  9D             - Atom 9
  9E             - Atom 10
  BC             - Atom 11
  BD             - Atom 12
  BE             - Atom 13
  DC             - Atom 14
  DD             - Atom 15
  DE             - Atom 16
  DF             - Atom 17
  FC <VarUInt30> - Copy N Literal bytes, N MUST be greater than 1
  FD <VarUInt30> - Decompress (dispense) atom N, N>17
  FE             - Extended functions (reserved)

  Decoder in IN_CBOR state expects same codepoints as in standard-conformant
  CBOR, plus actions from the table above. That is, on every standard element,
  it's length analyzed, and, for all opcodes except strings, corresponding
  number of bytes is output without interpreting - that is, these opcodes are
  meaningful only at start of CBOR element, or compressed substitution of that
  element, and not significant inside them (as in CBOR itself). Note that
  "opcode" here means initial byte, so that only initial byte and header
  (possibly up to 8 next bytes) are meant here, e.g. for map with two pairs
  single A2 byte is output, not entire structural contents of the map.

  For standard CBOR text and byte strings opcodes, after output of element
  header, decoder initializes `remaining_bytes` variable to length of element
  contents and switches to IN_BLOB state with other opcode set, leaving it
  back to IN_CBOR state when element is finished.

  For example, consider text string "foobarbaz1foobarbaz2foobarquux". It has
  CBOR encoding - original uncompressed text - as:

    78 1E 666F6F62617262617A 31 666F6F62617262617A 32 666F6F62617271757578

  (here spaces around "1" and "2" for better readability of text below)

  Suppose atom number 20 has value "foobarbaz" and atom number 3 value
  "foobarquux". Then in CBAR form it will be:

    78 1E  FD 14  31  FD 14  31  3E

  Here, decoder sees standard CBOR prologue of 30-byte text string, outputs
  it, initializes `remaining_bytes` variable to 30 (0x1e) and goes to IN_BLOB
  state. Then it sees FD command to output atom, which argument is 0x14,
  decimal 20 (in our example numbers are small enough for VarInt to fit in
  a byte). It outputs contents of atom 20, and decrements `remaining_bytes` by
  length of atom, 9. Then it sees plain 0x31 byte, outputs it, decrementing
  `remaining_bytes` by 1. Process repeats with next atom and byte 0x32.
  Finally, there is 0x3E, short single-byte opcode for atom 3, which is output
  and `remaining_bytes` variable reaches 0 as length of atom 3 matches it. So
  decoder exit IN_BLOB state and expects start of next CBOR element after this
  string.

  Note that FC and FD opcodes are same in both states. This is two-fold: it
  allows CBAR to skip over (copy as is) new CBOR opcodes, conflicting with
  CBAR, if such will appear in the future, and - more importantly - it allows
  to paste atoms or literals as CBOR fragments. For example, this allows for
  CBOR sequences or copying incomplete CBOR structures, like fragments of
  unclosed (unfinished) arrays or maps. It is possible because on each step,
  decoder do not check CBOR to be structurally valid (though it SHOULD do so
  for final document) - it just expects next CBOR element and nothing more.

  Opcodes 5C and 7C used for "type conversion": as atoms are binary strings,
  often it's common for entire CBOR element to consist of single atom. In this
  case, specifying length and then going to IN_BLOB state emits more bytes and
  processing, because length of atom is already known. Thus, e.g. 7C and atom
  number is converted on output to proper CBOR element header of atom length,
  folowed by atom contents. For example, if atom 13 is "outputData", then
  7C 0D is expanded to 6A 6F 75 74 70 75 74 44 61 74 - 6A corresponds to
  length of 10 bytes of atom contents in standard CBOR Major Type 3.

  Tag #6.10 may be applied not only to entire array (which is logically
  substituted to enclosing CBOR after uncompressing) but also to binary
  string. This is used for two purposes, however with the same implementation
  code. First is standalone #6.10 in CBOR stream - in this case, it is assumed
  that dictionary was setup earlier, either in the CBOR stream or by external
  application means, e.g. media type. That is, it is equivalent as if the same
  #6.10 with array with same dictionary was substituted in place of this bstr.
  Second purpose is for atom setup table to use previously defined atoms, see
  below.

  Dictionary is set up as follows.

  If an atom is simple CBOR element or structured construct (e.g. map), then
  it's content is not processed, just used as-is: e.g. map encoding including
  child key-value pairs), or 9 bytes for double-size floating point value
  (0xfb and 8 bytes of IEEE 754). If an atom is of Major Type 2 or 3, then
  only contents of this string is used, e.g. 63 666F6 for "foo" will result
  in 3-byte atom 666F6. However if an atom is bstr (Major Type 2) with tag
  #6.10, then it's contents processed (and expanded value then used) by the
  same CBAR unpacking process - but decoder start state is IN_BLOB (instead of
  IN_CBOR for main CBAR) with `remaining_bytes` initialized to infinity and
  error on premature end of input is suppressed. Atoms allowed inside decoding
  such atom are only those atoms defined earlier in this dictionary array.
  Decoder, however, may be told to start in IN_CBOR state if the bstr has
  additionally tag 24 or 63 (encoded CBOR or CBOR Sequence).

  Note that title says "and generic BLOB" - that is, tag #6.10 an a string
  without tag 24 or 63 is not decoded to CBOR or CBOR sequence after unpacking
  but left as just expanded string - for applications which want compression
  only on some their BLOBs, not structurally. It may be point of view that an
  atom with both tags 10 and 63 is exception as decoded sequence is NOT
  substituted as several elements of atoms array - but better view in
  implementation that atoms after expanding are immediately entered into
  internal table, in contrast to CBOR stream, where expanded contents is then
  fed to generic CBOR decoding process.

  Example from draft-cbor-packed, in higher compression variant (this is not
  quite CBOR diagnostic notation but hex codes for bytes should be familiar):

#6.10([                                                            / 2 bytes /
  /atoms/[                                                         / 1 byte  /
    "rgbValue",   #6.10(#2.11 C0 "Red"),  #6.10(#2.13 C0 "Green"),
  / #0 (9 bytes)  #1 (CA 4B C0 52 65 64)  #2 (8 bytes)            = 23 bytes /

    #6.10(#2.12 C0 "Blue"), "http://192.168.1.10",
  / #3 (7 bytes)            #4 (20 bytes)                         = 27 bytes /

    #6.10(#2.35 F7 "3:8445/wot/thing")), #6.10(#2.42 F8 "/MyLED/"),
  / #5 (CA 58 23 F7 ..-> 20 bytes )      #6 (CA 58 3A F8 ..-> 11 bytes) = 31 /

    "name", "@type",  "links",  "href",   "mediaType", "application/json",
  / #7 (5 b) #8 (5 b)  #9 (6 b)  #10 (5 b)  #11 (10 b)  #12 (17 b)    = 48 b /

    "outputData",   "valueType",    "type",        "writable",
  / #13 (11 bytes)  #14 (10 bytes)  #15 (5 bytes)  #16 (9 bytes)   = 35 bytes/

    #6.10(#6.63(#2.18 "outputData": { "valueType": { "type": "number" } } )),
  / #17 (CA D83F 52 6F FD0D A1 49 FD0E A1 44 FD0F 46 6E756D626572 -> 22 b) /

    ["Property"],                 "colorTemperatureChanged",
  / #18 (81 48 68 ..-> 10 bytes)  #19 (24 bytes)                  = 34 bytes /
  ],                                              / -> 220 bytes of contents /
  /bytedict/"",                                                   / = 1 byte /
  /CBAR/#2.308<                                                  / = 3 bytes /
  / { "name": "MyLED",       "interactions":              [      / 9+13+1    /
    A6 7C 07   65 4D794C4544  6c 696E746572616374696F6E73 86     / = 23 bytes/

  / {  "links": [  {  "href": "http://192.../rgbValueRed"         = 11 bytes /
    A5 7C 09    81 A2 7C 0A   78 35 F9       C1
  / "mediaType": "application/json" } ]                           =  4 bytes /
    7C 0B        7C 0C
  / "outputData": { "valueType": { "type": "number" } },          =  2 bytes /
    FD 0D
  / "name": "rgbValueRed", "writable": true,                      =  7 bytes /
    7C 05   7C 01          7C 10       F5
  / "@type": ["Property"] },                                      =  4 bytes /
    7C 08    FD 12

  / {  "links": [  {  "href": "http://192.../rgbValueGreen"       = 11 bytes /
    A5 7C 09    81 A2 7C 0A   78 37 F9       F5
  / "mediaType": "application/json" } ]                           =  4 bytes /
    7C 0B        7C 0C
  / "outputData": { "valueType": { "type": "number" } },          =  2 bytes /
    FD 0D
  / "name": "rgbValueGreen", "writable": true,                    =  7 bytes /
    7C 05   7C 02            7C 10       F5
  / "@type": ["Property"] },                                      =  4 bytes /
    7C 08    FD 12

  / {  "links": [  {  "href": "http://192.../rgbValueBlue"        = 11 bytes /
    A5 7C 09    81 A2 7C 0A   78 37 F9       F6
  / "mediaType": "application/json" } ]                           =  4 bytes /
    7C 0B        7C 0C
  / "outputData": { "valueType": { "type": "number" } },          =  2 bytes /
    FD 0D
  / "name": "rgbValueBlue", "writable": true,                     =  7 bytes /
    7C 05   7C 03           7C 10       F5
  / "@type": ["Property"] },                                      =  4 bytes /
    7C 08    FD 12

  / {  "links": [  {  "href": "http://192.../rgbValueWhite"       = 16 bytes /
    A5 7C 09    81 A2 7C 0A   78 37 F9       C0 5768697465
  / "mediaType": "application/json" } ]                           =  4 bytes /
    7C 0B        7C 0C
  / "outputData": { "valueType": { "type": "number" } },          =  2 bytes /
    FD 0D
  / "name": "rgbValueWhite",        "writable": true,             = 14 bytes /
    7C 05   6D C0 FC 05 5768697465  7C 10       F5
  / "@type": ["Property"] },                                      =  4 bytes /
    7C 08    FD 12

  / {  "links": [  {  "href": "http://192.../ledOnOff"            = 20 bytes /
    A5 7C 09    81 A2 7C 0A   78 32 F9    FC 08 6C65644F6e4F6666
  / "mediaType": "application/json" } ]                           =  4 bytes /
    7C 0B        7C 0C
  / "outputData": { "valueType": { "type": "boolean" } }          = 16 bytes /
    7C 0D        A1  7C 0E      A1 7C 0F  67 626F6F6C65616E
  / "name": "ledOnOff",         "writable": true,                 = 14 bytes /
    7C 05   68 6C65644F6e4F6666  7C 10       F5
  / "@type": ["Property"] },                                      =  4 bytes /
    7C 08    FD 12

  / {  "links": [  {  "href": "http:/.../colorTemperatureChanged" = 12 bytes /
    A5 7C 09    81 A2 7C 0A   78 41 F9   FD 13
  / "mediaType": "application/json" } ]                           =  4 bytes /
    7C 0B        7C 0C
  / "outputData": { "valueType": { "type": "number" } },          =  2 bytes /
    FD 0D
  / "name": "colorTemperatureChanged", "writable": true,          =  7 bytes /
    7C 05   7C 13                      7C 10       F5
  / "@type": [ "Event"         ] },                               =  9 bytes /
    7C 08    81 65 4576656E74

  / "@type": "Lamp",      "id":   "0",                            = 12 bytes /
    7C 08    64 4C616D70  62 6964 61 30
  /  "base":      "http://192.168.1.103:8445/wot/thing",          =  7 bytes /
    64 62617365   7C F8
  / "@context":                                                   =  9 bytes /
    68 40636F6E74657874
  / "http://192.168.1.102:8444/wot/w3c-wot-td-context.jsonld"     = 41 bytes /
    78 37 F7            FC 24 323A383434342F...6F6E6C64
  >                                               / -> 308 bytes of contents /
])

  for a 2+1+220+1+3+308 = 535 bytes total, which could be reduced to 529 by
  eliminating three FC xx codes (left for demonstration).

TODO non-high-compression but "encoder-implementation-friendly" variant for at
most 1 atom per string (repeated strings only), with additional LZ pass
- and with full form dict

TBD 20.12.24 another variant tag 0xFC Fast Compressable: strings have VarInt64
instead of contents, which is moved to separate strings section, where used as
offset into it, with offset threshold to be possible to `mmap()` common
dictionary on many documents; or VarInt64 may be other identificator, e.g.
`rowid` of text/BLOB in database where this document resides

for map merging, tag 63 Encoded CBOR Sequence may be used,
cbor-records 57342-57599 also instead of tag 114


TODO atoms length < 3 prohibited -> integers < 256 to splice are array numbers
  - just list as (* opcode => ?argument), e.g.
    ['@'=>1, '@'=>2, '{', '!'=> [], ..., CBAR, ? checksum]
    with atomarr being just common case of dict from scratch
    - here '{' have no args - generalize to chars > 64 ?

  ## Full form of dictionary setup

  Here array is processed sequentially - an operation folllowed by it's
  arguments and possibly return value, then followed by another operation,
  etc. As CBAR is for compression, operations - essentially method calls or
  functions - are single-character strings. However, in this specification
  they are usually referred by meaningful names, not just mnemonics.

  Operation for dictionary setup in decoder is as follows. At start of array,
  temporary variable space is created, which could be viewed as array of
  arrays: there are variables numbered from 0 to maximum possible 255
  (implementation may impose lower constraints), each being array of CBOR
  values. At end of dictionary array, all variables (arrays) except 0 are
  discarded, and variable 0 becomes dictionary array. This dictionary array
  is then processed from start to end exactly as in the simple form, expanding
  tagged with #6.10 values to final byte string, as usual.

  The variables in paragraph above are explicit, visible to entity providing
  instructions in dictionary setup array. Decoder, of course, will have other
  internal variables, such as lengths of arrays or integer indexes at arrays.

  Rationale: it could be possible to define processing without explicit
             variables, in a functional style - using somewhat like an AST of
	     function calls. However, this would require recursion support in
	     decoder and can be difficult to express by automated encoders,
	     not when dictionary transformation is constructed manually.
	     While one can argue that dictionary scoping is also somewhat
	     recursive, it requires just one more internal array variable from
	     decoder (and index on it), implementable with same data
	     structures as all other (CBOR) arrays.

  To save a byte in outer array (that is tagged with #6.10) in common case,
  more than one argument is wrapped in array itself, and possible return
  value(s) are after arguments, e.g.

    func-name (arguments) -> (where-to-assign)

  becomes

    'x', [+ arguments], where-to-assign

  e.g. for function `splice()` assigning return value to variable 5 (array 5):

    ..., '!', [1, 2, 3, 4], 5, ...

  If return value is to be discarded (as `(void)func(...)` in C), then CBOR
  `null` is used instead. Some functions do not have return value, in such
  case they occupy just two elements in outer array, if have arguments, or may
  be just function name, if no arguments are possible at all.

  Debatable: is it needed to encode number of arguments/return to function
             name somehow (e.g. let characters with ASCII code > 64 having no
	     arguments) or we don't need it? It's arguable that if decoder
	     cannot understand unknown function (from future revision), then
	     it cannot just skip it without harming correctness.

  Below are descriptions of allowed functions. At the start of processing
  outer temporary array is empty, e.g. even variable 0 is not assigned yet.

  "LIST" below means any number of array entries, including empty. Arguments
  in list that are integers less than 256 are references to variables - e.g.
  a whole array contents may be substituted.

  Descriptions are given as if copies are made, implementations are free to
  use optimization techniques like copy-on-write, however.

  ### Function '@' - import() dictionary

  Mnemonic: operate AT copy of referenced dictionary.

  Return value: no.

  Functional description:

       import DICT-REF
               Places a copy of dictionary referenced by sole argument to the
	       highest unused variable, e.g. at the very start it will be put
	       in variable (array) 0, if after that immediately follows another
	       import(), result will be put in variable 1, and so on. Note that
	       index of result is determined by solely size of outer array
	       (i.e. a this is a push() operation).

  Example:

      ['@', 12345678, '@', #6.32("http://192.168.1.1:8443/main.dict"), ...]

    copy contents of dictionary identified by application-specific number
    12345678 to variable 0 and dictionary identified by URL into variable 1.

  ### Function '!' - splice() an array

  Mnemonic: change contents of variables like in `diff -c` utility output.

  Return value: yes.

  Functional description:

       splice ARRAY,OFFSET,LENGTH,LIST
       splice ARRAY,OFFSET,LENGTH
       splice ARRAY,OFFSET
       splice ARRAY
               Removes the elements designated by OFFSET and LENGTH from an
               array, and replaces them with the elements of LIST, if any.  If
               return value is not null, put into that variable number the
	       elements removed from the array. The array grows or shrinks as
               necessary.  If OFFSET is negative then it starts that far from
               the end of the array.  If LENGTH is omitted, removes everything
               from OFFSET onward.  If LENGTH is negative, removes the
               elements from OFFSET onward except for -LENGTH elements at the
               end of the array.  If both OFFSET and LENGTH are omitted,
               removes everything.  If OFFSET is past the end of the array and
               a LENGTH was provided, decoder SHOULD issue a warning, and
	       splices at the end of the array.

               The following equivalences hold (assuming "length(a) > i" )

                   push(a,x,y)         splice(a,length(a),0,x,y)
                   pop(a)              splice(a,-1)
                   shift(a)            splice(a,0,1)
                   unshift(a,x,y)      splice(a,0,0,x,y)
                   a[i] = y            splice(a,i,1,y)

               "splice" can be used, for example, to implement n-ary queue
               processing:

                   sub nary_print {
                     my $n = shift;
                     while (my @next_n = splice @_, 0, $n) {
                       say join q{ -- }, @next_n;
                     }
                   }

                   nary_print(3, qw(a b c d e f g h));
                   # prints:
                   #   a -- b -- c
                   #   d -- e -- f
                   #   g -- h

  Example:

TODO

  ### Function ':' - store() dictionary for later use

  Mnemonic: name and value separator in JSON.

  Return value: no.

  Functional description:

       store DICT-REF
               Store resulting (after finishing processing) dictionary under
	       this dictionary reference, so that it could be used by decoder
	       later when such reference will appear in import() function.

	       Note that multiple occurences, with different references, are
	       allowed - same dictionary may be known by different names.

	       DICT-REF here MUST NOT refer to CBAR scope stack, only user
	       values are allowed.

  Example:

      ['!', [0,0,0,"A","B","C","D","E","F","G","H"], null, ':', 12345678, ...]

    variable 0 is populated from scratch by splice() function, no more actions
    (similar to simple form) and A B C D E F G H array will be known under
    12345678 reference for possible later use.

  ### Function '{' - enter() new dictionary scope ("stack frame")

  Mnemonic: open brace of function in Bourne Shell and C-like languages.

  Return value: no.

  Functional description:

       enter
               Remember the dictionary that was "upper in stack" and restore
	       it when current CBOR structural element finishes, e.g. when
	       matching "}" or "]" would be seen in diagnostic notation. Does
	       not affect the dictionary currently being built (temporary
	       variables) in any way except marking it to be thrown away at
	       the end of current block (except if store() function will store
	       another copy).

TBD what about scoping to end of current CBOR Sequence / top-level?

TBD possible problem is that, by default, without scoping dictionary is just
redefined "later in stream" - is it indended? arguably yes, because
alternative with scoping exists
- but what if one dictionary defined scoping and later did not?

TBD a way in DICT-REF to refer some variable? e.g. an API call sets
a var in decoder to some Message-Id before each message, then it may be used
for store() and import() like a template mechanism?

TBD recursion problem (nested CBAR after unpacking bytestr) - a tree of dicts?
- or better prohibit recursion at all in favor of scoping? as it requires
  additional memory and tree of dicts is too complex

TODO examples to DICT-REF:
   For example, in [IANA.cose] SHA-256 has the COSE algorithm identifier
   -16.  This is in the range -256 .. 255 (inclusive range).  Therefore,
   tag 18540 (= 18556 + (-16)) is the tag for a byte string containing a
   SHA-256 hash.

  ### Function 'Z' - zdict() for two-phases compression

  Mnemonic: zip/zli/zstd/etc. dictionary
  inflateSetDictionary()

TODO
