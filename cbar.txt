   !!! early draft!

      CBAR: CBOR and generic BLOBs by-Atom Reducing
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1.


1.1. Terminology

   Nibble - half of byte, 4 bits, one hexadecimal digit.

   Sextet - 6 bits, digit of 64-ary numeral system

2. VarNibble.

   This is a variable-length integer encoding on the sub-byte resolution. It
   occupies integral number of nibbles and utilizes addition scheme in
   a manner similar to CoAP [RFC 7252] option delta encoding: the lowest
   possible values are encoded as themselves, and at each increasing of length
   value zero of expanded bitfield is total 

   Enconding                                               Total values / zero
                                                           of next level's
      0                                                    Biased Value
      0 1 2 3
     +-+-+-+-+
     | 0..9  | Integers from 0 to 9, themselves
     +-+-+-+-+

      0               
      0 1 2 3 4 5 6 7 
     +-+-+-+-+-+-+-+-+
     |  0xa  |B.Val. | Integer Values from 10 to 25            10 + 16 = 26
     +-+-+-+-+-+-+-+-+

      0
      0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+
     |  0xb  | Biased Value  | Integer Values from 26 to 281   26 + 256 = 282
     +-+-+-+-+-+-+-+-+-+-+-+-+

      0                   1
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |  0xc  | Biased Value, 12 bits | ...and so on            282 + 4096
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      0                   1                   
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |  0xd  |     Biased Value, 16 bits     |                 4378 + 65536
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      0                   1                   2
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |  0xe  |         Biased Value, 20 bits         |         69914 + 1048576
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      0                   1                   2
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |  0xf  |             Biased Value, 24 bits             | 1118490 + 2^24
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   For example, integer value 17 is encoded as two nibbles 0xa7, and value 42
   is encoded as three nibbles 0xb14.


2.1. VarNibbles.

   This is array, occupying integral number of bytes, each individual element
   is a VarNible. How possible 4-bit padding is treated by upper layer, e.g.
   in a sequence of delta-encoding last nibble could just 0 (indicating no
   difference from previous value), and other schemes could employ explicit
   count of nibbles, so possible last nibble could be ignored if total number
   is odd.

3. The CBAR encoding.

   CBAR-based protocol defines two dictionaries: one is byte string, virtually
   prepended to output buffer for backreferences (but which is not part of
   output itself), and other dictionary is a set of atoms. In degenerate case
   both dictionaries are empty so that compression is possible only by RLE
   (run-length encoding) and backreferences in the compressed data itself.

   An atom is a byte string (3 bytes or more) which, with it's length, is
   known both to compressor and decompressor under some number. So, when
   decompressor sees instruction "use atom 42", it looks up 42-th entry in
   atom dictionary and substitutes this bytestring to output instead of atom
   number. Atoms are numbered from 0 (zero), and lower atom numbers are
   assumed to be used more often.

3.1. Wire format.

   The CBAR record as input to decompressor consists of integral number of
   bytes, which total length is told to decompressor by upper protocol. CBAR
   is inspired by SQLite Row Format [https://www.sqlite.org/fileformat2.html#record_format]
   but using VarNibbles. CBAR contains a header and a body, in that order, each
   of integral number of bytes. The header is a VarNibbles array, where each
   VarNibble is an instruction (operation code) to decompressor, and body,
   also called content area, contains bytes which are used by append to output
   buffer instructions.

   The header begins with a single VarNibble which determines the total number
   of nibbles in the header. The VarNibble value is the size of the header in
   nibbles including the size VarNibble itself, minus one. If size VarNibble
   is special value zero, this means "decompressed data is empty byte string"
   (in such a case, CBAR record MUST consist of a single byte 0x00, other
   possible values for low nibble are reserved).

   If header ended, but there are still unconsumed bytes in content area,
   all of them are appended to output as if header had implicit last
   instruction "append all bytes of remaining length". This allows to reduce
   overhead of uncompressible data to just 1 single byte of CBAR header.

   Following the size VarNibble are one or more additional VarNibbles, one
   per instruction. These additional VarNibbles are called "serial code"
   numbers and determine the instruction, according to the following chart:

TBD may be low bit in size VarNibble is flag so that next is CRC-24 [RFC 4880]
plus 1118490 (so it always 3 bytes to simplify encoder padding)
-> if such bit, only after some first values, to still allow 1-byte header
  -> instead bit, put RLE a1 instead of CRC if first operation is fxxxxxx?

TBD problem with nibble alignment when generating - moving 4 Mb due to odd len is not fun

       0   1   2   3   4   5   6   7
     +---+---+---+---+---+---+---+---+...
     | 0 |Header Len |Header Area, 7 nibbles max 
     +---+---+---+---+---+---+---+---+...

so for len 0 it is 0x00 byte meaning empty string

for below, off by one, hlen = 0 means one, and:
    if (CRC) hlen += 7
    if (Nxt) hlen += 1

       0   1   2   3   4   5   6   7
     +---+---+---+---+---+---+---+---+=============+==============+
     | 1   0 |CRC|   Header Length   | Header Area | Content Area |
     +---+---+---+---+---+---+---+---+=============+==============+

       0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15
     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+...
     | 1   1 |CRC|Nxt|                 Header Length                 |
     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+...

TBD this is 12 bit, make it another 3rd byte so 11 bit / 19 bit?

TBD why CRC in VarNibble? this is waste of 4 bits

-- variant 2:

0x00 .. 0x09 = empty string or VarNibble - 1 (0..8)

       0   1   2   3   4   5   6   7
     +---+---+---+---+---+---+---+---+...
     | 0 |   Opcode Length + 3   |CRC|
     +---+---+---+---+---+---+---+---+...

       0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15
     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+...
     | 1 |Nxt|CRC|               Opcode Length - 60                  |
     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+...

TBD why CRC at all? caller may use any wanted algorithm

TBD flag "Next" has same problem as header itself - length not yet known at start

-- variant 3:

0x00 .. 0x09 = empty string or VarNibble - 1 (0..8)

       0   1   2   3   4   5   6   7
     +---+---+---+---+---+---+---+---+...
     |  9 < Opcode Length + 8 < 240  | Instruction Area 1 to 116 bytes
     +---+---+---+---+---+---+---+---+...

  249 - 241 nibbles and 12 bits literal length
  250 - 242 nibbles and 8 bits literal length
  251 - 241 nibbles and 20 bits literal length
  252 - 242 nibbles and 16 bits literal length
  253 - 241 nibbles
  254 - 242 nibbles and 24 bits literal length
  255 - 241 nibbles and 28 bits literal length

TBD no, up to 7 nibbles may be when still has to next

       0   1   2   3   4   5   6   7
     +---+---+---+---+---+---+---+---+...
     | 1   1   1   1 | Tail  | Next  | Instruction Area 1 to 116 bytes
     +---+---+---+---+---+---+---+---+...

TBD just size VarNibble at end if next?


RFC 7400 quote:
   +----------+---------------------------------------------+----------+
   | code     | Action                                      | Argument |
   | byte     |                                             |          |
   +----------+---------------------------------------------+----------+
   | 0kkkkkkk | Append k = 0b0kkkkkkk bytes of data in the  | k bytes  |
   |          | bytecode argument (k < 96)                  | of data  |
   |          |                                             |          |
   | 1000nnnn | Append 0b0000nnnn+2 bytes of zeroes         |          |
   |          |                                             |          |
   | 10010000 | stop code (end of compressed data; see      |          |
   |          | Section 3.2)                                |          |
   |          |                                             |          |
   | 101nssss | Set up extended arguments for a             |          |
   |          | backreference: sa += 0b0ssss000,            |          |
   |          | na += 0b0000n000                            |          |
   |          |                                             |          |
   | 11nnnkkk | Backreference: n = na+0b00000nnn+2;         |          |
   |          | s = 0b00000kkk+sa+n; append n bytes from    |          |
   |          | previously output bytes, starting s bytes   |          |
   |          | to the left of the current output pointer;  |          |
   |          | set sa = 0, na = 0                          |          |
   +----------+---------------------------------------------+----------+

TBD ssss nnn kkk widths for backref/args instructions

   Serial Code | Hex  | Action
   ============+======+==============================================
        0      |  0   | Append 0x00
        1      |  1   | Append 0x01
        2      |  2   | Prefix next element with CBOR Major 2 length
        3      |  3   | Prefix next element with CBOR Major 3 length
        4      |  4   | Append 0xf4 (CBOR false)
        5      |  5   | Append 0xf5 (CBOR true)
        6      |  6   | Append 0xf6 (CBOR null)
        7      |  7   | Append 0xff
        8      |  8   | Append 0x20 (CBOR -1)
        9      |  9   | Append 1 content byte
   ------------+------+----------------------------------------------
        10     |  a0  | Append 2 content bytes 
        11     |  a1  | RLE: repeat last output
        12     |  a2  | RLE: repeat last output 2 times
        13     |  a3  | RLE: repeat last output 3 times
        14     |  a4  | RLE: repeat last output 4 times
        15     |  a5  | RLE: repeat last output 5 times
        16     |  a6  | RLE: repeat last output 6 times
        17     |  a7  | RLE: repeat last output 7 times
        18     |  a8  | RLE: repeat last output 8 times
        19     |  a9  | RLE: repeat last output 9 times
        20     |  aa  | Set up extended argument for backreference: na += 16
        21     |  ab  | Set up extended argument for backreference: na += 32
        22     |  ac  | Set up extended argument for backreference: na += 64
        23     |  ad  | Set up extended argument for backreference: na += 128
        24     |  ae  | Set up extended argument for backreference: na += 256
        25     |  af  | Reserved for future use, MUST throw error
   ------------+------+---------------------------------------------
    for N>=26:  R = 0 | Append atom with number M
      if even,        |
         set:   R = 2 | Append M+3 content bytes
    M=(N-26)/4        |
    R=(N-26)%4        |
                      | Backreference: n = na + (B % 16), s = (B / 16) + n,
      if odd,         | append n bytes from previously output bytes,
       set B=(N-26)/2 | starting s bytes to the left of the current
                      | output pointer; set na = 0

TBD

   To illustrate how different operations interact with others (especially
   prefixes and RLE), the following pseudocode defines how decompressor
   funstions use variables:

    append(src, len):
        if (src == NULL)
	    throw decode error
        if (prefix) {
            char prefbuf[9]
            pl = encode_cbor_uint(len)
            prefbuf[0] |= (prefix == 2) ? 0x40 : 0x60

            obuf[optr .. optr+pl-1] = prefbuf[0 .. pl-1]
            optr += pl

            prefix = 0;
       }

       obuf[optr .. optr+len-1] = src[0 .. len-1]
       lastoptr = optr
       lastlen  = len

       optr += len

    append_short(code):
        shorts = {0x00, 0x01, NULL, NULL, 0xf4, 0xf5, 0xf6, 0xff, 0x20}
        append(shorts[code], 1)

    append_content(N):
        append(content[iptr], N)
	iptr += N

TBD include prefix in RLE or not?
    rle(count):
        while (count-- > 0) {
	    obuf[optr .. optr+lastlen-1] = obuf[lastoptr .. last_optr+lastlen-1]
	    optr += lastlen
	}

    atom(M):
        append(atoms[M][0], length(atoms[M]))

    backreference(s, n):
        n += na + 2
        append(obuf[optr - s - n], n)
	na = 0

TODO


6. Using CBAR inside CBOR.

   CBAR is a building block for other protocols, and some protocols may want
   to augment CBOR decoder with CBAR decompressor. In such case, CBAR is
   contained in a CBOR byte string (Major Type 2) inside a tagged array, and
   from the consumer point of view result of CBAR decompression is "replaces"
   this array. In this array, everything except CBAR bytestring is optional,
   with default values defined by upper layer protocol.

   Instead of directly supplying atoms array (where each atom number is just
   index of string in array) with bytestring dictionary, applications may also
   choose to just refer to some dictionary defined in other place, by
   specifying it's hash for error checking. This is similar to specifying
   CRC-32 / Adler-32 checksum of deflate dictionary in zlib library, or in
   LZ4 frame.

TBD correct CDDL syntax

   CBAR-CBOR = #6.10([atoms, bytedict, CBAR, checksum])  ; Tag 0x0a for "Atom"
             / #6.10(CBAR)    ; binary string - everything other setup earlier

   atomarr = [ + bstr ]

   atoms = atomarr / uint / bstr,    ; atoms array (mb empty) or their hash
   bytedict = bstr / uint,           ; byte dictionary (mb empty) or it's hash
   CBAR = bstr .size (9..),
   ? checksum = uint

TBD may be RFC 6920 ?

TODO

=========== Format with bytes & Pyramint5 instead of VarNibbles =====

   This is a variation of static Huffman encoding of unsigned integer, in
   a "pyramid" way, where first (most wide) is exact value, and each next level
   is in "units" of next power of two after maximal value of previous level. Levels are
   encoded as bit prefixes 0, 10, 110, etc.

   For example, Pyramint5 is

   * 0aaaa - unit is 1, so values 00000 to 01111 are 0..15
   * 10bbb - now unit is 16, 15+1, and bbb=000 means 16, bbb=001 means 32,
             so e.g. overall Pyramint5 value 10001 means 32, and maximal value
	     at this level, bbb=111 and overall Pyramint5 10111 - is 128.
   * 110cc - remember, zero value at next level is next power of two, not just
             one "unit", so cc=00, or overall 11000, is 256 now! Then are 512, 768
	     and maximum - 1024.
   * 1110d - at the last level only one bit it left, so there are just two
             values - 2048 and 4096.
   * 11110 - we also can define this as 8192, though no bits left
   * 11111 - similarly, maximum possible value will be 16384

   Extending one bit, we get Pyramint6 as follows:

   0aaaaa  - 0..31 * unit=1
   10bbbb  - 0..15 * unit=32    -> from 32    to max 512
   110ccc  - 0..7  * unit=1024  -> from 1024  to max 8192
   1110dd  - 0..3  * unit=16384 -> from 16384 to max 65536
   11110e  - 0..1  * unit=128 K -> from 128 K to max 256 K
   111110  - 512 K
   111111  - 1 M

pyramint4:                             1000 1001 1010 1011 1100 1101 1110 1111  
  0    1    2    3    4    5    6    7    8   16   32   64  128  256  512 1024

   additional information values:
   +------------+------------------------------------+----------+
   | 00000nnn  | Append 0b00000nnn+1 bytes of zeroes
   | 00001nnn  | Append 0b00000nnn+1 bytes of 0xff
   | 0x10   16 | Append 0x20 (CBOR int -1)
   | 0x11   17 | Append 0x01 (CBOR int 1)
   | 0x12   18 | Append 0x02 (CBOR int 2)
   | 0x13   19 | Append 0x03 (CBOR int 3)
   | 0x14   20 | Append 0xf4 (CBOR false)
   | 0x15   21 | Append 0xf5 (CBOR true)
   | 0x16   22 | Append 0xf6 (CBOR null)
   | 0x17   23 | Append ??? 
   | 0x18   24 | RLE: repeat last output
   | 0x19   25 | RLE: repeat last output 2 times
   | 0x1a   26 | RLE: repeat last output 4 times
   | 0x1b   27 | RLE: repeat last output 8 times
   | 0x1c   28 | Reserved
   | 0x1d   29 | Reserved
   | 0x1e   30 | Reserved
   | 0x1f   31 | Stop code: append everything what left in literals
   +------------+------------------------------------+----------+

TBD text string can't contain repeated runs of 00/f4/f5/f6/ff !


main bytecodes:
   +-------------------+------------------------------------+----------+
   |                   | 
   | 000kkkkk          | Append k+1 bytes of data in the bytecode argument
   |                   | 
   | 001kkkkk kkkkkkkk | Append k+31 bytes of data in the bytecode argument
   |                   | 
   | 010kkkkk          | Append k+23 bytes of data in the bytecode argument,
   |                   | prefixed with CBOR Major 2 length of k+23 (bstr)
   |                   | 
   | 011kkkkk          | Append k+23 bytes of data in the bytecode argument,
   |                   | prefixed with CBOR Major 3 length of k+23 (tstr)
   |                   | 
   | 100ddddd          | Special values from additional information 
   |                   | 
   | 1010tttt tttttttt | Atom: append content of atom a=aa+0b0tttttttttttt,
   |                   | set aa = 0
   |                   | 
   | 1011iiii          | aa += 4096 * (0b0iiii + 1);
   |                   | 
   |                   | Set up extended arguments for a backreference:
   |                   | 
   | 1100ssss          | sa += 512 * (0b0ssss + 1)
   |                   | 
   | 1101nnnn          | na += 0b0nnnn0000 + 16
   |                   | 
   | 111nnnnk kkkkkkkk | Backreference: n = na+0b0000nnnn+2;
   |                   | s = k+sa+n; append n bytes from
   |                   | previously output bytes, starting s bytes
   |                   | to the left of the current output pointer;
   |                   | set sa = 0, na = 0
   +-------------------+------------------------------------+----------+

perl -E 'use CBOR::XS; sub true {1}; print encode_cbor [
   ["algorithm", "HMAC", "SHA1"] => true,
   ["algorithm", "HMAC", "SipHash", 0, 0] => 2,
   ["algorithm", "HMAC", "SipHash", 0, 1] => 4,
   ["algorithm", "kex"] => [
   				"curve25519-sha256",
				"curve25519-sha256@libssh.org",
				"ecdh-sha2-nistp256",
				"ecdh-sha2-nistp384",
				"ecdh-sha2-nistp521",
				"diffie-hellman-group-exchange-sha256",
				"diffie-hellman-group16-sha512",
				"diffie-hellman-group18-sha512",
				"diffie-hellman-group14-sha256",
				"diffie-hellman-group14-sha1"
			],
   ["algorithm", "key"] => [
				"ssh-rsa",
				"rsa-sha2-512",
				"rsa-sha2-256",
				"ecdsa-sha2-nistp256",
				"ssh-ed25519"
			],
   ["algorithm", "ciphers"] => [
				"chacha20-poly1305@openssh.com",
				"aes128-ctr",
				"aes192-ctr",
				"aes256-ctr",
				"aes128-gcm@openssh.com",
				"aes256-gcm@openssh.com",
				"aes128-cbc",
				"aes192-cbc",
				"aes256-cbc"
			],
   ["assoc", "retrans", "max"] => 3,
   ["dev", "cpu", 0, "temperature"] => 64.1,
]' | hexdump -C
00000000  90 83 49 61 6c 67 6f 72  69 74 68 6d 44 48 4d 41  |..IalgorithmDHMA|
00000010  43 44 53 48 41 31 f5 85  49 61 6c 67 6f 72 69 74  |CDSHA1..Ialgorit|
00000020  68 6d 44 48 4d 41 43 47  53 69 70 48 61 73 68 00  |hmDHMACGSipHash.|
00000030  00 02 85 49 61 6c 67 6f  72 69 74 68 6d 44 48 4d  |...IalgorithmDHM|
00000040  41 43 47 53 69 70 48 61  73 68 00 01 04 82 49 61  |ACGSipHash....Ia|
00000050  6c 67 6f 72 69 74 68 6d  43 6b 65 78 8a 51 63 75  |lgorithmCkex.Qcu|
00000060  72 76 65 32 35 35 31 39  2d 73 68 61 32 35 36 55  |rve25519-sha256U|
00000070  63 75 72 76 65 32 35 35  31 39 2d 73 68 61 32 35  |curve25519-sha25|
00000080  36 2e 6f 72 67 52 65 63  64 68 2d 73 68 61 32 2d  |6.orgRecdh-sha2-|
00000090  6e 69 73 74 70 32 35 36  52 65 63 64 68 2d 73 68  |nistp256Recdh-sh|
000000a0  61 32 2d 6e 69 73 74 70  33 38 34 52 65 63 64 68  |a2-nistp384Recdh|
000000b0  2d 73 68 61 32 2d 6e 69  73 74 70 35 32 31 58 24  |-sha2-nistp521X$|
000000c0  64 69 66 66 69 65 2d 68  65 6c 6c 6d 61 6e 2d 67  |diffie-hellman-g|
000000d0  72 6f 75 70 2d 65 78 63  68 61 6e 67 65 2d 73 68  |roup-exchange-sh|
000000e0  61 32 35 36 58 1d 64 69  66 66 69 65 2d 68 65 6c  |a256X.diffie-hel|
000000f0  6c 6d 61 6e 2d 67 72 6f  75 70 31 36 2d 73 68 61  |lman-group16-sha|
00000100  35 31 32 58 1d 64 69 66  66 69 65 2d 68 65 6c 6c  |512X.diffie-hell|
00000110  6d 61 6e 2d 67 72 6f 75  70 31 38 2d 73 68 61 35  |man-group18-sha5|
00000120  31 32 58 1d 64 69 66 66  69 65 2d 68 65 6c 6c 6d  |12X.diffie-hellm|
00000130  61 6e 2d 67 72 6f 75 70  31 34 2d 73 68 61 32 35  |an-group14-sha25|
00000140  36 58 1b 64 69 66 66 69  65 2d 68 65 6c 6c 6d 61  |6X.diffie-hellma|
00000150  6e 2d 67 72 6f 75 70 31  34 2d 73 68 61 31 82 49  |n-group14-sha1.I|
00000160  61 6c 67 6f 72 69 74 68  6d 43 6b 65 79 85 47 73  |algorithmCkey.Gs|
00000170  73 68 2d 72 73 61 4c 72  73 61 2d 73 68 61 32 2d  |sh-rsaLrsa-sha2-|
00000180  35 31 32 4c 72 73 61 2d  73 68 61 32 2d 32 35 36  |512Lrsa-sha2-256|
00000190  53 65 63 64 73 61 2d 73  68 61 32 2d 6e 69 73 74  |Secdsa-sha2-nist|
000001a0  70 32 35 36 4b 73 73 68  2d 65 64 32 35 35 31 39  |p256Kssh-ed25519|
000001b0  82 49 61 6c 67 6f 72 69  74 68 6d 47 63 69 70 68  |.IalgorithmGciph|
000001c0  65 72 73 89 55 63 68 61  63 68 61 32 30 2d 70 6f  |ers.Uchacha20-po|
000001d0  6c 79 31 33 30 35 2e 63  6f 6d 4a 61 65 73 31 32  |ly1305.comJaes12|
000001e0  38 2d 63 74 72 4a 61 65  73 31 39 32 2d 63 74 72  |8-ctrJaes192-ctr|
000001f0  4a 61 65 73 32 35 36 2d  63 74 72 4e 61 65 73 31  |Jaes256-ctrNaes1|
00000200  32 38 2d 67 63 6d 2e 63  6f 6d 4e 61 65 73 32 35  |28-gcm.comNaes25|
00000210  36 2d 67 63 6d 2e 63 6f  6d 4a 61 65 73 31 32 38  |6-gcm.comJaes128|
00000220  2d 63 62 63 4a 61 65 73  31 39 32 2d 63 62 63 4a  |-cbcJaes192-cbcJ|
00000230  61 65 73 32 35 36 2d 63  62 63 83 45 61 73 73 6f  |aes256-cbc.Easso|
00000240  63 47 72 65 74 72 61 6e  73 43 6d 61 78 03 84 43  |cGretransCmax..C|
00000250  64 65 76 43 63 70 75 00  4b 74 65 6d 70 65 72 61  |devCcpu.Ktempera|
00000260  74 75 72 65 fb 40 50 06  66 66 66 66 66           |ture.@P.fffff|

perl -E 'use CBOR::XS; print encode_cbor [
   [30, 31, 32]		=> \1,              
   [30, 31, 33, 0, 0]	=> 2,
   [30, 31, 33, 0, 1]	=> 4,
   [30, 34]		=> [35, 36, 37, 38, 39, 40, 41, 42, 43, 44],
   [30, 45]		=> [46, 47, 48, 49, 50],
   [30, 51]		=> [52, 53, 54, 55, 56, 57, 58, 59, 60],
   [61, 62, 63]		=> 3,
   [64, 65, 0, 66]	=> 64.1,
]' | hexdump -C
00000000  90 83 18 1e 18 1f 18 20  f5 85 18 1e 18 1f 18 21  |....... .......!|
00000010  00 00 02 85 18 1e 18 1f  18 21 00 01 04 82 18 1e  |.........!......|
00000020  18 22 8a 18 23 18 24 18  25 18 26 18 27 18 28 18  |."..#.$.%.&.'.(.|
00000030  29 18 2a 18 2b 18 2c 82  18 1e 18 2d 85 18 2e 18  |).*.+.,....-....|
00000040  2f 18 30 18 31 18 32 82  18 1e 18 33 89 18 34 18  |/.0.1.2....3..4.|
00000050  35 18 36 18 37 18 38 18  39 18 3a 18 3b 18 3c 83  |5.6.7.8.9.:.;.<.|
00000060  18 3d 18 3e 18 3f 03 84  18 40 18 41 00 18 42 fb  |.=.>.?...@.A..B.|
00000070  40 50 06 66 66 66 66 66                           |@P.fffff|
00000078
perl -E 'use CBOR::XS; use Compress::LZF; print compress_best encode_cbor [
   [30, 31, 32] => Types::Serialiser::true,
   [30, 31, 33, 0, 0] => 2,
   [30, 31, 33, 0, 1] => 4,
   [30, 34] => [35, 36, 37, 38, 39, 40, 41, 42, 43, 44],
   [30, 45] => [46, 47, 48, 49, 50],
   [30, 51] => [52, 53, 54, 55, 56, 57, 58, 59, 60],
   [61, 62, 63] => 3,
   [64, 65, 0, 66] => 64.1,
]' | hd                                                                        
00000000  78/09 90 83 18 1e 18 1f  18 20 f5 85#60 07/03 21  |x........ ..`..!|
00000010  00 00 02#c0 09/02 01 04  82#20 09/15 22 8a 18 23  |......... .."..#|
00000020  18 24 18 25 18 26 18 27  18 28 18 29 18 2a 18 2b  |.$.%.&.'.(.).*.+|
00000030  18 2c#40 19/0b 2d 85 18  2e 18 2f 18 30 18 31 18  |.,@..-..../.0.1.|
00000040  32#40 0f/1f!33 89 18 34  18 35 18 36 18 37 18 38  |2@..3..4.5.6.7.8|
00000050  18 39 18 3a 18 3b 18 3c  83 18 3d 18 3e 18 3f 03  |.9.:.;.<..=.>.?.|
00000060  84 18 40 18/08 41 00 18  42 fb 40 50 06 66#20 00  |..@..A..B.@P.f .|
00000070 /00 66                                             |.f|


TODO


      0  
      0 1 2 3 4 5
     +-+-+-+-+-+-+
     |   0..47   | Integers from 0 to 47, themselves
     +-+-+-+-+-+-+

      0          |    
      0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+
     |1 1 0 0| Biased Value  | Integer Values from 48 to 303  48 + 256 = 304
     +-+-+-+-+-+-+-+-+-+-+-+-+

      0          |        1  |
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |1 1 0 1|       Biased Value        | 304 ... 16687    304 + 2^14 = 16688
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      0          |        1  |           |    2
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |1 1 1 0| Value as is (for simplicity), 20 bits |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      0          |        1  |           |    2      |
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |1 1 1 1|       Value as is (for simplicity), 26 bits       |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


Header Opcode Length:

    0x00 - empty string

      0               
      0 1 2 3 4 5 6 7 
     +-+-+-+-+-+-+-+-+
     |    1 .. 48    | Single Sextet 0 .. 47
     +-+-+-+-+-+-+-+-+

      0               
      0 1 2 3 4 5 6 7 
     +-+-+-+-+-+-+-+-+
     |   49 .. 127   | Number of sextets, 2 .. 80
     +-+-+-+-+-+-+-+-+

      0                   1
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |1 0|Number of sextets, 14 bits |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


      0                   1                   2
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |1 1|        Number of sextets, 22 bits         |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Serial Code | Action
   ============+==============================================
       0..3    | Append 1..4 times 0x00
       4..7    | Append 1..4 times 0xff
         8     | Prefix next element with CBOR Major 2 length
         9     | Prefix next element with CBOR Major 3 length
        10     | Set up extended argument for backreference: na += 16
        11     | Set up extended argument for backreference: na += 32
        12     | Set up extended argument for backreference: na += 64
        13     | Set up extended argument for backreference: na += 128
        14     | Set up extended argument for backreference: na += 256
   | 0x09   15 | Append 0x21 (CBOR int -2)
   | 0x10   16 | Append 0x20 (CBOR int -1)
   | 0x11   17 | Append 0x01 (CBOR int 1)
   | 0x12   18 | Append 0x02 (CBOR int 2)
   | 0x13   19 | Append 0x03 (CBOR int 3)
   | 0x14   20 | Append 0xf4 (CBOR false)
   | 0x15   21 | Append 0xf5 (CBOR true)
   | 0x16   22 | Append 0xf6 (CBOR null)
   | 0x17   23 | Append 0x2c (comma, CBOR -13, SSH list separator) 
   | 0x18   24 | RLE: repeat last output
   | 0x19   25 | RLE: repeat last output 2 times
   ------------+---------------------------------------------
    for N>=26:  R = 0 | Append atom with number M
      if even,        |
         set:   R = 2 | Append M+1 content bytes
    M=(N-26)/4        |
    R=(N-26)%4        |
                      | Backreference: n = na + (B % 16), s = (B / 16) + n,
      if odd,         | append n bytes from previously output bytes,
       set B=(N-26)/2 | starting s bytes to the left of the current
                      | output pointer; set na = 0


TODO

=========== Format with VarInt15 instead of VarNibbles =====

as in bytes, no header area
..or VarInt22 ? or make it not int but just short/mid/long


      0               
      0 1 2 3 4 5 6 7 
     +-+-+-+-+-+-+-+-+
     |0| Short codes | 
     +-+-+-+-+-+-+-+-+

      0                   1
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |1|0 0 0|Atom number, 0 .. 4095 |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      0                   1
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |1|Len-1|Backreference offset-1 | non-zero 3 bits, that is, 0x9..0xe
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      0                   1                   2
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |1|1 1 1|Backreference offset-1 |  Length - 9   |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   +----------+----------------------------------------------+----------+
   |  short   | Action                                       | Argument |
   |  code    |                                              |          |
   +----------+----------------------------------------------+----------+
   | 0kkkkkkk | Append k = 0b0kkkkkkk + 1 bytes of data in   | k bytes  |
   |          | the bytecode argument; k <= 80               | of data  |
   |          |                                              |          |
   | 0101kkkk | Append k = 0b0kkkk bytes of data in the      | k bytes  |
   |          | bytecode argument, prefixed with their       | of data  |
   |          | length in CBOR Major Type 2 (k+1 total);     |          |
   |          | that is, first byte is 0x4k                  |          |
   |          |                                              |          |
   | 011rrvvv | Append n = 0b0rr + 1 identical bytes with    |          |
   |          | value from table below; n is 1, 2 or 3 so    |          |
   |          | rr is 0b000 to 0b010                         |          |
   |          |                                              |          |
   | 01111011 | Append byte 0xd6 (Tag cbor-packed)           |          |
   |          |                                              |          |
   | 01111100 | Append byte 0x2c (ASCII comma "," which is   |          |
   |          | list separator in SSH)                       |          |
   |          |                                              |          |
   | 01111101 | Append two bytes 0xd8 0x19 (Tag stringref)   |          |
   |          |                                              |          |
   | 0111111a | stop code - end of compressed data;          |          |
   |          | if a=0 then add all remaining literal bytes  |          |
   |          | if a=1 then just stop                        |          |
   +----------+----------------------------------------------+----------+


   vvv | Byte  | Commentary 
   ====+=======+==========================
    0  | 0x00  | CBOR Integer 0
    1  | 0x01  | CBOR Integer 1
    2  | 0x02  | CBOR Integer 2
    3  | 0x20  | CBOR Integer -1
    4  | 0xf4  | CBOR false
    5  | 0xf5  | CBOR true
    6  | 0xf6  | CBOR null
    7  | 0xff  | also commonly occurs repeated
    
   An uncompressed length before CBAR raw stream is encoded as single UTF-8
   character as it was in [RFC 2279], that is, allowing values up to 2^31-1
   in six bytes. Length 0 means that no compression was achieved, so remaining
   data should be copied to output buffer as is, without applying
   decompression. Stop codes allow to add data such as a checksum at end of
   stream. If such checksum, or CRC, or hash, is used, then it MUST cover
   uncompressed data. If space constraints are serious, but 16-bit
   checksums/CRCs are considered weak, then CRC-24 [RFC 4880] could be
   recommended.

TODO

=========== Two-pass Format: LZF + Atoms =====

   External format: use Compress::LZF as is

   Internal pass: for CBOR, use unused codes 28..30 in each Major Type. For
   integers, it's shorter one (e.g. 3-byte), for each string type, prefix it
   with atom length as prescribed by CBOR, for tags, put common like
   stringref, and in special, make generic escape mechanism:

   e.g. 0xfc to escape one byte
   0xfd - extended escape, and e.g. for atoms in middle of strings

TBD what extended escapes?

TBD if 3 codes in each type, are 768 atoms enough? may reuse from map/array,
but isn't just 1535 коряво?

TODO what should be internal pass for non-CBOR but just SSH blob?
and need some another format for uncompressed length prefix

TBD if literal in CBOR, then this means unsupported so switching back to CBOR
cannot be reliable?

so:
  FC - copy 2+ bytes literal
  FD - dispense (decompress) atom
  FE - escape a single byte

and all 0xFx codes switch off CBOR going to BLOB mode

TBD is VarInt15 enough for atom number and FC length and in byte strings?

need we preserve indefinite-length strings with atoms inside? probably yes,
ULP may have crypto etc.

TBD may be simply wait for draft-cbor-packed to settle instead of "atom
surrounded in string"?

 |  Taking into account the encoding of these referring data items, there
 |  are 16 one-byte references, 48 two-byte references, 512 three-byte
 |  references, 131072 four-byte references, etc.  As CBOR integers can
 |  grow to very large (or very negative) values, there is no practical
 |  limit to how many shared items might be used in a Packed CBOR item.

TBD cbor-packed is less effective in Tag 6, however, what if replace unused codes
with Tag 6, e.g. 0x5C A0 being equivalent to d6 18 a0 ?

huh, the task of several atoms in a bytestring is almost equivalent to non-CBOR BLOB

possible solution:
  * for BLOB media type, initialize "remaining_bytes" to entire length, and go
    to INBLOB state
  * in CBOR state every opcode is allowed, and special one for strings emits
    CBOR string prefix, then sets remaining_bytes to string's length
  * in BLOB state, only FC/FD/FE allowed, any other MUST throw error, and
    decrement remaining_bytes for every emitted piece
  * when remaining_bytes becomes zero, go back to CBOR state

so, for strings:

  5C - 2+ byte length (varint) BLOB state inside
  5D - decompress one atom
  5E - single byte length BLOB state inside

and same for UTF-8 text strings (7C/7D/7E)

TBD what if use simple(0)..simple(15) for first atoms? so mb change varint to 240
- that may substitute CBOR fragment as-is, so requires stricter typing in atom
  setup, that is, InternAtom/GetAtomName/ReleaseAtom
  - use VarNibbles record format there? differentiate CBAR and CBAP?

=== 15.12.24:

This is proposed alternative to draft-cbor-packed as it's complete
replacement.

Example in draft-cbor-packed compressed to 503 bytes of 1210, or 41.6%,
while CBAR example for same 1210 bytes data gave 535 bytes 1210, or 44.2%
compression - and 2.6% difference is definetely not worth such waste of tags
and simple values registration as draft-cbor-packed wants to.

Short PROs and CONs of CBAR over cbor-packed:

+ supports placing any number of compressible substrings anywhere, including
  CBOR fragments; cbar-packed supports only complete, prefix or suffix
  replacement (talking about single step here)
+ packing of CBOR sequences - cbor-packed not, CBAR allows (a consequence of
  previsous point)
+ generic but simple to implement: cbor-packed overcomes aforementioned
  limitation by recursive reference tracking and join functions - but this is
  complex to implement and solves just some ad-hoc cases and not completely
+ uses just ONE tag, cbor-packed uses millions of tags
+ supports packing not only CBOR, but also generic unstructured BLOBs, e.g.
  a single bytestring inside CBOR document or even non-CBOR application
  message
+ has a generalized solution for dictionary management
+ has a support for secondary compression by traditional algorithms, e.g.
  deflate, providing a dictionary for it
- most compression is inside binary string: thus cbor-packed is more readable
  by tools giving diagnostic notation but not supporting CBAR
- compression is slightly worse than cbor-packed (by 2.6% on LED example)
- will not handle well if CBOR itself will ever be extended by new bytecodes
  (will be able to copy it as literal, but not utilize)

Everything is discutable, including name: it was initially born for specific
protocol's (muSCTP) needs as "compact binary arrays representation" in a try
to be more compact than CBOR by doing on sub-byte level, but was abandoned as
achieved compression (10 bytes vs 11 of CBOR in typical header) was considered
not justifying increased complexity of implementation, so switched to generic
CBOR compression scheme.

Most discutable is multiple-dictionaries-in-document management: in contrast
to external references (e.g. SHA-256 of well-known stable dict), this is
about volatile like "@context" in JSON-LD, so I did not decided which variant
to take - end of file is currently bunch of semi-structured mind-stream of
TBDs.

As dict management is open research problem, any comments are appreciated.

      CBAR: CBOR and generic BLOBs by-Atom Reducing
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  This is a format for compression of both unstructured raw BLOBs and CBOR
  documents by concept of "atom" (see Lisp and X11 windowing system) - a short
  integer used instead of (probably very) long string. A set of atoms, that
  is, mapping between integers and strings, is called "dictionary" here, using
  "just" this word (there is also "byte dictionary" meaning a pre-supplied
  block of bytes to compressors supporting it, like zlib or zstd). Reason for
  using atoms is that such strings are typically already present in
  (constrained) implementation's memory (as opposed to byte dictionary). CBAR
  provides facilities for dictionary management: as different CBOR documents
  will require different sets of atoms for better compression, dictionaries
  can be referenced from outside, changed on the fly throughout document, etc.

-- as this "draft of draft" is currently being discussed in comparison to
   [draft-ietf-cbor-packed], it is currently terse, assuming reader at least
   barely familiar with things discussed in CBOR WG mailing list and
   cbor-packed draft

  Dictionary management is not something was consistently done through
  IETF protocols yet. JSON-LD did a good work, through using "@context", but
  it focused mainly on human readability and editability, rather than on
  compression. RADIUS protocol had something similar to atoms in the sense of
  integer mapping to strings, but dictionary had to be set up manually by
  network administrator matching on both sides. YANG in CBOR used concept of
  SID, while simple to implement, avoiding dictionary management at all - it
  is globally unique and "set in stone" forever, even if specification is
  later corrected or withdrawn, thus reducing possible compression ratio.
  Moreover, current specification does not attempt to compress YANG bits
  (tag #6.43), while CBAR capable to do it. And CBOR-LD draft, as of end of
  December 2024, did not proceed to clear architecture or at least adequately
  readable specification, while trying to allocate rather large set of tags
  (see e.g. [https://github.com/json-ld/cbor-ld-spec/issues/38]), so there are
  good chances that CBOR-LD could be instead replaced by small specification
  on top of CBAR about exact format of dictionary references (e.g. register
  a tag) and how to interpret retrieved content from them to CBAR needs.

  Moreover, even ASN.1/X.509/RFC 9090 examples could be reduced by CBAR, e.g.
  example their about "buildingName (0.9.2342.19200300.100.1.48)" encoding is
  longer than would be typical atom, and for other 3 byte examples chances are
  atom could be 2 bytes.

  The format is described in terms of unpacker copying data from input to
  target unpacked CBOR which later can be feed to generic CBOR decoder,
  however, it is possible, though hard, to implement in-place access to
  CBAR data (like in draft-cbor-packed), if application wish so and is
  constrained in RAM but not ROM. Thus, CBAR is designed so it does not
  prohibit such implementation directly in CBOR decoder - however,
  implementers are warned that this is error-prone. In other words, CBAR can
  be viewed as a simple templating mechanism for CBOR like a POSIX Shell could
  be used as a simple templating mechanism for text: that is, a text is
  a sequence of variable assignments and variable substitutions, possibly
  utilizing previous variables, and so on.

  In-place access to CBAR (and in-place access in cbor-packed), however, is
  analogous to POSIX Make(1) utility - where variable expansion is deferred
  until actual use, often requiring to track them recursively - which is
  frequently hard to maintain even for human dealing with text Makefiles,
  implementing it "like make" for binary format can be even harder.

  CBAR allows for dictionary setup both outside of CBOR document (the main
  value is that atoms don't need to be passed with each application message)
  and inside, both as part of CBOR structure, or pre-setup - e.g. as CBOR
  sequence previous to current one.

  An (incomplete) CDDL for CBAR is shown here as a brief overview. As most of
  this documents deal with raw bytes, not everything could be expressed as
  CDDL and/or EDN so it wasn't polished/corrected.

   CBAR-CBOR = #6.10([atoms, bytedict, CBAR, ? checksum])  ; 0x0a for "Atom"
             / #6.10([ (+ commands), CBAR, ? checksum])    ; full form
             / #6.10(CBAR)    ; binary string - everything other setup earlier

   atomarr = [ + atom ]       ; "atom" is like in X11 sense - number of string
   atom = bstr                ; raw value
        / tstr                ; contents as raw value
        / #6.10(bstr)         ; itself CBAR - definition uses previous atoms
	/ any                 ; valid CBOR fragment to substitute

   atoms = atomarr / uint / bstr,    ; atoms array (mb empty) or their hash
   bytedict = bstr / uint,           ; byte dictionary (mb empty) or it's hash
   CBAR = null / bstr .size (3..),   ; may have e.g. 40003 tag if DEFLATE'd
   checksum = uint

  In atom definitions, each definition MUST use only prior atom numbers if
  it's CBAR itself (that is, defined with #6.10 tag).

  An atom MUST be for a string with at least 3 bytes long, and representation
  of atom SHOULD be shorter than string itself (or compression will not be
  achieved, leaving just templating).

TBD use 22098 for recursive "after unpacking, there are more CBAR inside"?

  ## Model of operation.

  Encoder and decoder are described here in object-oriented terms, though
  implementation is not obliged to be OO-style. At some point, new object is
  instantiated (constructor called), on which methods could be called, either
  for settings (e.g. canonical mode) or for actual CBOR processing. From this
  specification's point of view, a decoder object holds state needed for
  unpacking, that is, primarily dictionaries of atoms. This state could be
  modified by application calling methods on object, outside of any CBOR
  processing, and thus CBAR information is defined in such way that is
  equivalent to "in-band" calling of such state-modifying methods.

  A generalized view of application protocol is ordered sequence of messages
  decoded (or a sub-sequence if partial ordered):

   new()       Message 1                   Message 2
     |      .-------------.     .----------------------------.
     |      | CBOR Item 1 |     |        CBOR Sequence       |
     |      |             |     |-------------+--------------|
     |      |             |     | CBOR Item 1 | CBOR Item 2  |
     |----->|             |---->|             |              |----> ...
     |      |             |     |             | {      lvl 1 |
     |      |             |     |             |   [    lvl 2 |
     |      |             |     |             |     {  lvl 3 |
     |      |             |     |             |     },       |
     |      |             |     |             |     s, lvl 2 |
            `-------------'     `-------------+--------------'

  However, observe that generic decoder does not need to know application
  messages' boundaries - to support CBOR Sequences, it is enough for decoder
  to have methods e.g. `decode()` and `decode_prefix()` both accepting buffer
  with bytes (e.g. pointer and length), where former method expects entire
  buffer consists of complete CBOR item and latter decodes complete CBOR item
  returning number of bytes consumed from buffer (note such interface is
  unified for both CBOR Sequences and incremental parsing of partially
  received stream).

  Thus, for decoder the diagram above is in fact equivalent to single message
  with three CBOR sequences or 3 messages - it's merely for application where
  it may call additional methods after the initial `new()` constructor and
  settings methods.

  CBAR is intended to be used in scenarios where packing information is known
  beforehand, so it is possible to achieve better compression by not including
  dictionary in each CBOR message, but provide it out of band. Of course, full
  support of inline (in CBOR stream itself) dictionaries definition is
  supported, as well as multiple dictionaries and redefining them inside of
  complex CBOR structures - similar in spirit to JSON-LD's "@context"'s. On
  the diagram above there is map containg array containing other map and
  string, elements of outer map wuld have level 1 of nesting, elements of
  array are on level 2 (including string s), and elements in map in array
  would be on level 3. Thus, each top-level CBOR item could be viewed as being
  on level 0.
 
  ## Tag equivalence

  This section borrows same chapter from [draft-cbor-packed] and extends it
  for CBAR in adding exceptions to generic rule for nested tags where it was
  equivalent to leave outer tag and replace inner tag with it's
  modified/substituted contents: for Tag #6.10, a tag following it (that is,
  inner to it) may be "modifier" to it. For example,

    #6.10(#6.63("binary string"))

  means that binary string after unpacking (with dictionary set up somewhere
  before) must be "substituted", omitting both tags, as CBOR elements in this
  place. If that binary string is to be left as is for application in unpacked
  CBOR, then just `#6.10("binary string")` is used. If application wants
  a binary string, just tagged as CBOR Sequence, then tag is moved out:

    #6.63(#6.10("binary string")

TBD 10.01 02:40 or that tag could be just inside binary string itself?

TODO table of #6.10 sequences variants TBD where to put Alternatives if 63/24?
- 09.04.25 09:30 as YAML defines Tag to be URI, we can take URI idea that it
  can have ?query=part&in=no&particular=order

  This way, tag #6.10 could be used just for binary strings unpacking, not
  altering CBOR tree structure at all - hence "B" in "CBAR" is for generic
  BLOBs. And both methods could be combined in same CBOR stream.

  ## Rules of Tag #6.10 substituitions

  Example of substituting bare tag #6.10 for binary strings already was given
  (only to remind here is that inner tag 24 also could be used for complete
  CBOR item, not sequence). Tag #6.10 on an array where CBAR member is
  non-null is always expanded as complete CBOR item (unless CBAR member has
  tag #6.63 on it, then as sequence) - because it is useless to setup
  dictionary for just one binary string, so it's not supported.

TBD is it?

  The other possible application of Tag #6.10 is on integers, where integer is
  atom number, expanding to a single string, with positive integers expanding
  to binary strings (Major Type 2) and negative to text strings (Major Type
  3)
TBD mnemonic is to add 2 to major type, but is it friendly?

TODO 23.01.25 #6.10(24(uint)) must expand to complete CBOR item
- 24.01.25 and #6.10(63(uint)) to CBOR Sequence, but only inside array

  This is in fact just another way to write #6.10(#6.24(h'7C /atom num/') or
  with "5C" for binary string, saving a byte for atom numbers less than 65536
  and having additional benefits:

  * simplified encoders/decoders may operate on single atoms rather than deep
    scanning of strings concatenated from pieces
  * a tag with a number is more readable in Diagnostic Notation than binary
    string with a prefix and varint

==probably remove this:
  And last use of Tag #6.10 is on undefined as map key (that is, two bytes
  0xDA 0xF7), where map's value for such key is array for dictionary setup
  (that is, in which CBAR member is null). It is described later in section
  on nesting decitionaries.
==/probably remove

  A tag #6.10 on map with Alternatives Tag (121+) defines a "namespace" where
  another dictionary is used - that is, it allows for multiple dictionaries
  in one message, on different level (think of JSON-lD's "@context"). Recall
  image above:

   {                      ; level 1 - default dictionary
     [                    ; level 2 
       #6.10(#6.123({     ; level 3 uses dictionary numer 3
               #6.10(1),  ; expanded to "foobar"
	       ...
             })),               
             #6.10(s2),   ; level 2 again
	     #6.10(1),    ; expanded to "quux"

  The same is for arrays, but to distinguish from dictionary setup, using
  #6.10 on namespace as array MUST always have Alternative (e.g. #6.121 for
  default 0), and dictionary setup MUST NOT have an Alternative Tag on it.

  All other uses of Tag #6.10 are reserved for future use and MUST NOT be
  emitted by conforming encoders for now version.

  ## Dictionary setup - tag #6.10 on array

  Tag #6.10 always sets up dictionary for use later in stream. It may have
  CBAR member (last or before checksum), which is then expanded using this
  dictionary and substituted in place of entire tagged array - or CBAR member
  may be null, meaning this is just dictionary setup for later use (e.g. on
  individual bytestrings or integers, see examples above). In any case, tagged
  array is "cutted" from unpacked CBOR, as if were not existing - thus
  preferred place for dictionary is at top-level CBOR Sequence (level 0 on the
  messages diagram above).

  Dictionary setup can be in two forms: simple and full. Simple is:

    #6.10([atoms, bytedict, CBAR, ? checksum])

  Where `atoms` is array explicitly assigning atom in dictionary by index in
  array - first, i.e. index 0 is array, is atom 0, then atom 1 and so on.

  Full form instead of `atoms` array and `bytedict`  consists of commands and
  their arguments, occuping everything till CBAR (and possibly checksum)
  members. Commands (opcodes) are single-character strings which have single
  outer array member after them - also an array if more than one argument
  needed. That is, it is like a key-value list (like map), but in array form,
  may have odd number and is processed sequentially.

  Rationale: naturally, it could have been a map, but map could have entries
             in any order, so it would require from decoder to 1) buffer
	     everything till end of map is seen and start processing only
	     then, and 2) some way to reference between map entries, when
	     there is more than one operation of same type (that is, requiring
	     array under a single map key). Thus, in array form it is possible
	     for decoder to process entries immediately as they are seen,
	     simplifying implementation and lowering memory requirements,
	     while also allowing variable number of parameters per operation.

  Full form at last produces an (in-memory) array of strings, which is then
  processed same as array in simple form. Thus, first simple form and overall
  CBAR decoder operation will be described, and then full form in later
  section.

  # Details of CBAR operation and simple-form dictionary

  VarUInt30 means variable-length unsigned integer capable of holding at
  most 30 bits, by the following bit patterns (from MSB to LSB):
  * 0aaaaaaa                             - 7 bits, values 0..127 coded as-is
  * 100aaaaa bbbbbbbb                    - 13 bits
  * 101aaaaa bbbbbbbb cccccccc           - 21 bits
  * 11aaaaaa bbbbbbbb cccccccc dddddddd  - 30 bits

  Rationale: As this compression is targeted primarily towards constrained
             implementations, those supporting more than 32 bits are
             considered unconstrained - that is, e.g. more than 4 Gbytes
             chunks of data. And 2^30 atoms will require 5 Gbytes of memory at
             minimum; for literal lengths 2^30 bytes is also unlikely to
             surpass when other memory from 4 Gbytes is needed for other
             purposes.

             However, if discussion will conclude that 60+ bits needed (e.g.
             for unification with YANG SID), alternative VarUInt60 supporting
	     60 bits in 8 bytes is posible:

             0..143 values coded as themselves                    bits:
             1001aaaa bbbbbbbb                                     - 12
             1010aaaa bbbbbbbb cccccccc                            - 20
             1011aaaa bbbbbbbb cccccccc dddddddd                   - 28
             1100aaaa bbbbbbbb cccccccc dddddddd eeeeeeee          - 36
             1101aaaa bbbbbbbb cccccccc dddddddd eeeeeee  ffffffff - 44
             1110aaaa bbbbbbbb cccccccc dddddddd   ...    gggggggg - 52
             1111aaaa bbbbbbbb cccccccc dddddddd   ...    hhhhhhhh - 60

             Or even full 64 bits in 9 bytes is possible:

             0..191 values coded as themselves                     bits:
             110aaaaa bbbbbbbb                                     - 13
             1110aaaa bbbbbbbb cccccccc                            - 20
             11110aaa bbbbbbbb cccccccc dddddddd                   - 27
             111110aa bbbbbbbb cccccccc dddddddd eeeeeeee          - 34
             11111100 aaaaaaaa bbbbbbbb cccccccc dddddddd eeeeeeee - 40
             11111101 aaaaaaaa bbbbbbbb cccccccc   ...    ffffffff - 48
             11111110 aaaaaaaa bbbbbbbb cccccccc   ...    gggggggg - 56
             11111111 aaaaaaaa bbbbbbbb cccccccc   ...    hhhhhhhh - 64

  Opcodes of IN_BLOB state, with possible <argument N>:

  C0             - Atom 0
  C1             - Atom 1
  F5             - Atom 2
  F6             - Atom 3
  F7             - Atom 4
  F8             - Atom 5
  F9             - Atom 6
  FA             - Atom 7
  FB             - Atom 8
  FC <VarUInt30> - Copy N Literal bytes, N MUST be greater than 1
  FD <VarUInt30> - Decompress (dispense) atom N
  FE byte/VInt21 - Escape next byte (Copy 1 literal byte) or Extended functions
  FF             - Copy remaining_bytes literal bytes
  any other byte - Output this byte

  FE code is special: if next byte following has value 0xC0 or more, then it
  is escape - argument is exactly this byte, which is just escaped, or, in
  other words, it is shorter version of FC 01 <escaped_byte>. Otherwise, if
  value is less than 0xC0, then it is treated as VarUInt30 Extended functions
  (see section about them below). However, due to format of VarUInt30, if it's
  first byte is less than 0xC0, then value is limited to 21 bits. Therefore,
  any Extended function MUST have number less than 2097152.

TBD this hard to deal with remaining_bytes, forbid? discuss in section below

  Any output operation decrements `remaining_bytes` variable by the size of
  chunk output, and in well-formed input it MUST not became less than zero.
  If `remaining_bytes` became zero (0), state is changed to IN_CBOR.

  Rationale: UTF-8 since it's updated RFC can't encode codepoints higher than
             0x10FFFF, thus bytes higher than 0xF5 can't appear in well-fromed
	     UTF-8, and 0xC0 and 0xC1 also must not appear in conforming
	     UTF-8, thus these bytes could be used inside CBOR Major Type 3
	     (string) without escaping(*), as atoms often will be part of text
	     strings, not only binary. For applications wanting to trade-off
	     performance to compression ratio, every other byte means itself
	     which allows to scan contents of text string byte-by-byte, saving
	     few bytes - instead, for performance of decoder, FC code with
	     length should be used, allowing to skip to next code.

	     (*) This, of course, means not raw CBOR text strings (where such
	     bytes are prohibited) but substrings of CBAR which will become
	     valid CBOR data items after atom substitutions.

  Opcodes of IN_CBOR state, with <arguments> (and (mnemonics)):

  1C <3 bytes>   - (terCio) Output 1A 00 <3 bytes>
  1D             - Atom 0
  1E             - Atom 1
  1F <5 bytes>   - (Five) Output 1B 00 00 00 <5 bytes>
  3C <3 bytes>   - (terCio) Output 3A 00 <3 bytes>
  3D             - Atom 2
  3E             - Atom 3
  3F <5 bytes>   - Five-integer: Output 3B 00 00 00 <5 bytes>
  5C <VarUInt30> - Convert atom N to binary string
  5D             - Atom 4
  5E             - Atom 5
  7C <VarUInt30> - Convert atom N to text string
  7D             - Atom 6
  7E             - Atom 7
  9C             - Atom 8
  9D             - Atom 9
  9E             - Atom 10
  BC             - Atom 11
  BD             - Atom 12
  BE             - Atom 13
  DC             - Atom 14
  DD             - Atom 15
  DE             - Atom 16
  DF             - Atom 17
  FC <VarUInt30> - Copy N Literal bytes, N MUST be greater than 1
  FD <VarUInt30> - Decompress (dispense) atom N, N>17
  FE <VarUInt30> - Extended functions

  Decoder in IN_CBOR state expects same codepoints as in standard-conformant
  CBOR, plus actions from the table above. That is, on every standard element,
  it's length analyzed, and, for all opcodes except strings, corresponding
  number of bytes is output without interpreting - that is, these opcodes are
  meaningful only at start of CBOR element, or compressed substitution of that
  element, and not significant inside them (as in CBOR itself). Note that
  "opcode" here means initial byte, so that only initial byte and header
  (possibly up to 8 next bytes) are meant here, e.g. for map with two pairs
  single A2 byte is output, not entire structural contents of the map.

  For standard CBOR text and byte strings opcodes, after output of element
  header, decoder initializes `remaining_bytes` variable to length of element
  contents and switches to IN_BLOB state with other opcode set, leaving it
  back to IN_CBOR state when element is finished.

  For example, consider text string "foobarbaz1foobarbaz2foobarquux". It has
  CBOR encoding - original uncompressed text - as:

    78 1E 666F6F62617262617A 31 666F6F62617262617A 32 666F6F62617271757578

  (here spaces around "1" and "2" for better readability of text below)

  Suppose atom number 20 has value "foobarbaz" and atom number 3 value
  "foobarquux". Then in CBAR form it will be:

    78 1E  FD 14  31  FD 14  31  3E

  Here, decoder sees standard CBOR prologue of 30-byte text string, outputs
  it, initializes `remaining_bytes` variable to 30 (0x1e) and goes to IN_BLOB
  state. Then it sees FD command to output atom, which argument is 0x14,
  decimal 20 (in our example numbers are small enough for VarInt to fit in
  a byte). It outputs contents of atom 20, and decrements `remaining_bytes` by
  length of atom, 9. Then it sees plain 0x31 byte, outputs it, decrementing
  `remaining_bytes` by 1. Process repeats with next atom and byte 0x32.
  Finally, there is 0x3E, short single-byte opcode for atom 3, which is output
  and `remaining_bytes` variable reaches 0 as length of atom 3 matches it. So
  decoder exit IN_BLOB state and expects start of next CBOR element after this
  string.

  Note that FC and FD opcodes are same in both states. This is two-fold: it
  allows CBAR to skip over (copy as is) new CBOR opcodes, conflicting with
  CBAR, if such will appear in the future, and - more importantly - it allows
  to paste atoms or literals as CBOR fragments. For example, this allows for
  CBOR sequences or copying incomplete CBOR structures, like fragments of
  unclosed (unfinished) arrays or maps. It is possible because on each step,
  decoder do not check CBOR to be structurally valid (though it SHOULD do so
  for final document) - it just expects next CBOR element and nothing more.

  Opcodes 5C and 7C used for "type conversion": as atoms are binary strings,
  often it's common for entire CBOR element to consist of single atom. In this
  case, specifying length and then going to IN_BLOB state emits more bytes and
  processing, because length of atom is already known. Thus, e.g. 7C and atom
  number is converted on output to proper CBOR element header of atom length,
  folowed by atom contents. For example, if atom 13 is "outputData", then
  7C 0D is expanded to 6A 6F 75 74 70 75 74 44 61 74 - 6A corresponds to
  length of 10 bytes of atom contents in standard CBOR Major Type 3.

  Tag #6.10 may be applied not only to entire array (which is logically
  substituted to enclosing CBOR after uncompressing) but also to binary
  string. This is used for two purposes, however with the same implementation
  code. First is standalone #6.10 in CBOR stream - in this case, it is assumed
  that dictionary was setup earlier, either in the CBOR stream or by external
  application means, e.g. media type. That is, it is equivalent as if the same
  #6.10 with array with same dictionary was substituted in place of this bstr.
  Second purpose is for atom setup table to use previously defined atoms, see
  below.

  Dictionary is set up as follows.

  If an atom is simple (types 0, 1, 7) CBOR element or structured construct
  (Major Type 4 or 5, e.g. map), then it's content is NOT processed, just used
  as-is: e.g. map encoding including child key-value pairs), or 9 bytes for
  double-size floating point value (0xfb and 8 bytes of IEEE 754). Note that,
  in order to support constrained implementations or implementations above
  a generic encoder/decoder, keeping exact serialization (in addition to
  parsed CBOR tree) can be memory-consuming or impossible to obtain. Thus, as
  possible re-encoding to CBOR, while retaining semantics, may lead to
  different chunk of bytes (e.g. order of map keys or float vs double), it
  SHOULD NOT be relied upon in applications requiring checksums or
  cryptographic signatures (some out-of-band negotiation of whether encoding
  is deterministic may be needed).

  If an atom is of Major Type 2 or 3, then only contents of this string is
  used, e.g. 4 hex bytes 63 666F6 of CBOR text string "foo" will result
  in 3-byte atom 666F6. However if an atom is bstr (Major Type 2) with tag
  #6.10, then it's contents processed (and expanded value then used) by the
  same CBAR unpacking process - but decoder start state is IN_BLOB (instead of
  IN_CBOR for main CBAR) with `remaining_bytes` initialized to infinity and
  error on premature end of input is suppressed. Atoms allowed inside decoding
  such atom are only those atoms defined earlier in this dictionary array.
  Decoder, however, may be told to start in IN_CBOR state if the bstr has
  additionally tag 24 or 63 (encoded CBOR or CBOR Sequence).

  Note that title says "and generic BLOB" - that is, tag #6.10 an a string
  without tag 24 or 63 is not decoded to CBOR or CBOR sequence after unpacking
  but left as just expanded string - for applications which want compression
  only on some their BLOBs, not structurally. It may be point of view that an
  atom with both tags 10 and 63 is exception as decoded sequence is NOT
  substituted as several elements of atoms array - but better view in
  implementation that atoms after expanding are immediately entered into
  internal table, in contrast to CBOR stream, where expanded contents is then
  fed to generic CBOR decoding process.

  #### Extended functions

  These are currently defined only for numbers 121-127 and 1280-1400, to be
  on par with Alternatives Tags encoding. But in contrast to using tags on
  structural CBOR elements, inside binary string these extended functions just
  switch dictionaries without keeping state - and tags do "push" and "pop" on
  stack levels.

TBD 07.02.25 think about unification of them with stack machine for atoms, to
use not only for packing (where only static atom substitution enough) but also
as general templating mechanism, e.g. generating arrays with [% FOREACH %]
- 08.02 05:26 `{vars} {body} 'foreach'` in Tcl speak - yeah, we already have
  FC for {$this} ! so define one extended function, which MUST be followed by
  literal copy, which will push this literal to stack, instead of default
  "output" action, and another - for other arguments... may be also FC with
  CBOR Sequence in it of those like in atoms dict setup?
  - 05:35 but if Extended Functions have same codes as tstr commands, why not
    just use them? only one CBOR item as argument?
    - no, it will clash with (constrained) parsers who don't support this
      particular function, escape is a must
    - isn't literal copy above a form of CBOR bstr push like in dict setup?
      - no, they parsed differently: CBAR bstr consists of CBOR element's byte
        sequences whose action is roughly "immediately output()" (or append to
        argument stack both bstr and output() function for it)
        - 21:35 why "immediately output()" after each? it may be single
          implicit output() at the end for whatever arguments are; then FC
          just adds to S (just as usual IN_CBOR elements) and corresponding
          FE now may be after it, not before
          - then it will be hard in foreach() as it pushed arg before body?
            - 18.02.25 (see also this day) mb workable with different forms of
              foreach() e.g. with variables instead of stack? as previous was
              noted before TAGN() and typed FC support
              - 23:24 stack was for DNS: so that body may be appended to list
                by macro; as it is macro anyway, solvable by arg before body
                which is null if just stack and count if there are more
                vars/list pairs
                - 23:30 may be a supplement command to '(' which will convert
                  to number of arguments?
                - 23:30 add functions 'reverse' (of list) for looping down to,
                  and creating range from list before it on stack, so
                  foreach() could receive two lists, main and "i++" for
                  checking number TBD what for '.first()/.last()' ? sublist?
          - 23.02 Rivet/minirivet also converts to outputCommand, it's just
            that *execution* of this command need not be immediate (or it will
            break flow control), but with stack machine such code generation
            is probably harder to achieve than in prefix, and surely harder to
            manually write binary template than in traditional style
      - 09.02 00:57 we just need a way to at least *somewhat* resemble
        Template::Toolkit with it's substs in text instead of manual bunch of
        print()s, so let it be 'tp' ('template_parse') function (also
        implicitly applied to CBAR-rump initially) which converts our format
        to sequence of [..., literal, 'output', arg, 'func', literal, 'output']
        by splice()ing it (just like if/foreach), so body of 'foreach' now may
        be simplified to [..., commands, 'bstr-template-body', 'tp', ...] or
        several ones, but at least not for every individual element
        - 03:50 CBOR's bstr ai/length bytes and then 'tp' occupy space... for
          common case where only one at end may provide FE code so that CBOR
          ends with FF, rest of length is known (we are in FC), so that tail
          is automatically conversed to bstr plus 'tp'
    - 05:56 how to marry this with `remaining_bytes` variable...
      - just forbid it for IN_BLOB? but then how to template BLOBs...
      - 07:00 variable needed only to switch parser states - so mb other tool
        in such case; also foreach-like templating is generally used outside
        of bstr's (structural: for maps and arrays), but even if it is, then
        for dynamic content it's also hard to predict enclosing CBOR's string
        length (it generating by template case, not packing existing CBOR) -
        and we cannot return back and set string length after all loops... the
        solution here is probably to prepare temporary atom before and then
        issue 5C/7C (probably surrounded by dictionary switches) to convert
        it to final string
        - 09.02 01:30 if we going to support delta-encoding like in YACTS/VTS or
          SenML, then probably also need 1C/3C to be "convert to CBOR int"
          (not atoms)
    - 22:09 define tstr/bstr codes to be looking same bytes in hexdump
      * 10000001 bbbbbbbb          - that is, 256..511
      * 10100010 bbbbbbbb cccccccc - 131073..+65535
      and low bits of first byte like additional info in tstr/bstr 1/2 bytes

  ### Examples

  Example from draft-cbor-packed, in higher compression variant (this is not
  quite CBOR diagnostic notation but hex codes for bytes should be familiar):

#6.10([                                                            / 2 bytes /
  /atoms/[                                                         / 1 byte  /
    "rgbValue",   #6.10(#2.11 C0 "Red"),  #6.10(#2.13 C0 "Green"),
  / #0 (9 bytes)  #1 (CA 4B C0 52 65 64)  #2 (8 bytes)            = 23 bytes /

    #6.10(#2.12 C0 "Blue"), "http://192.168.1.10",
  / #3 (7 bytes)            #4 (20 bytes)                         = 27 bytes /

    #6.10(#2.35 F7 "3:8445/wot/thing")), #6.10(#2.42 F8 "/MyLED/"),
  / #5 (CA 58 23 F7 ..-> 20 bytes )      #6 (CA 58 3A F8 ..-> 11 bytes) = 31 /

    "name", "@type",  "links",  "href",   "mediaType", "application/json",
  / #7 (5 b) #8 (5 b)  #9 (6 b)  #10 (5 b)  #11 (10 b)  #12 (17 b)    = 48 b /

    "outputData",   "valueType",    "type",        "writable",
  / #13 (11 bytes)  #14 (10 bytes)  #15 (5 bytes)  #16 (9 bytes)   = 35 bytes/

    #6.10(#6.63(#2.18 "outputData": { "valueType": { "type": "number" } } )),
  / #17 (CA D83F 52 6A FD0D A1 49 FD0E A1 44 FD0F 46 6E756D626572 -> 22 b) /

    ["Property"],                 "colorTemperatureChanged",
  / #18 (81 48 68 ..-> 10 bytes)  #19 (24 bytes)                  = 34 bytes /
  ],                                              / -> 220 bytes of contents /
  /bytedict/"",                                                   / = 1 byte /
  /CBAR/#2.308<                                                  / = 3 bytes /
  / { "name": "MyLED",       "interactions":              [      / 9+13+1    /
    A6 7C 07   65 4D794C4544  6C 696E746572616374696F6E73 86     / = 23 bytes/

  / {  "links": [  {  "href": "http://192.../rgbValueRed"         = 11 bytes /
    A5 7C 09    81 A2 7C 0A   78 35 F9       C1
  / "mediaType": "application/json" } ]                           =  4 bytes /
    7C 0B        7C 0C
  / "outputData": { "valueType": { "type": "number" } },          =  2 bytes /
    FD 11
  / "name": "rgbValueRed", "writable": true,                      =  7 bytes /
    7C 05   7C 01          7C 10       F5
  / "@type": ["Property"] },                                      =  4 bytes /
    7C 08    FD 12

  / {  "links": [  {  "href": "http://192.../rgbValueGreen"       = 11 bytes /
    A5 7C 09    81 A2 7C 0A   78 37 F9       F5
  / "mediaType": "application/json" } ]                           =  4 bytes /
    7C 0B        7C 0C
  / "outputData": { "valueType": { "type": "number" } },          =  2 bytes /
    FD 11
  / "name": "rgbValueGreen", "writable": true,                    =  7 bytes /
    7C 05   7C 02            7C 10       F5
  / "@type": ["Property"] },                                      =  4 bytes /
    7C 08    FD 12

  / {  "links": [  {  "href": "http://192.../rgbValueBlue"        = 11 bytes /
    A5 7C 09    81 A2 7C 0A   78 37 F9       F6
  / "mediaType": "application/json" } ]                           =  4 bytes /
    7C 0B        7C 0C
  / "outputData": { "valueType": { "type": "number" } },          =  2 bytes /
    FD 11
  / "name": "rgbValueBlue", "writable": true,                     =  7 bytes /
    7C 05   7C 03           7C 10       F5
  / "@type": ["Property"] },                                      =  4 bytes /
    7C 08    FD 12

  / {  "links": [  {  "href": "http://192.../rgbValueWhite"       = 16 bytes /
    A5 7C 09    81 A2 7C 0A   78 37 F9       C0 5768697465
  / "mediaType": "application/json" } ]                           =  4 bytes /
    7C 0B        7C 0C
  / "outputData": { "valueType": { "type": "number" } },          =  2 bytes /
    FD 11
  / "name": "rgbValueWhite",        "writable": true,             = 14 bytes /
    7C 05   6D C0 FC 05 5768697465  7C 10       F5
  / "@type": ["Property"] },                                      =  4 bytes /
    7C 08    FD 12

  / {  "links": [  {  "href": "http://192.../ledOnOff"            = 20 bytes /
    A5 7C 09    81 A2 7C 0A   78 32 F9    FC 08 6C65644F6e4F6666
  / "mediaType": "application/json" } ]                           =  4 bytes /
    7C 0B        7C 0C
  / "outputData": { "valueType": { "type": "boolean" } }          = 16 bytes /
    7C 0D        A1  7C 0E      A1 7C 0F  67 626F6F6C65616E
  / "name": "ledOnOff",         "writable": true,                 = 14 bytes /
    7C 05   68 6C65644F6e4F6666  7C 10       F5
  / "@type": ["Property"] },                                      =  4 bytes /
    7C 08    FD 12

  / {  "links": [  {  "href": "http:/.../colorTemperatureChanged" = 12 bytes /
    A5 7C 09    81 A2 7C 0A   78 41 F9   FD 13
  / "mediaType": "application/json" } ]                           =  4 bytes /
    7C 0B        7C 0C
  / "outputData": { "valueType": { "type": "number" } },          =  2 bytes /
    FD 0D
  / "name": "colorTemperatureChanged", "writable": true,          =  7 bytes /
    7C 05   7C 13                      7C 10       F5
  / "@type": [ "Event"         ] },                               =  9 bytes /
    7C 08    81 65 4576656E74

  / "@type": "Lamp",      "id":   "0",                            = 12 bytes /
    7C 08    64 4C616D70  62 6964 61 30
  /  "base":      "http://192.168.1.103:8445/wot/thing",          =  7 bytes /
    64 62617365   7C F8  /FIXME/
  / "@context":                                                   =  9 bytes /
    68 40636F6E74657874
  / "http://192.168.1.102:8444/wot/w3c-wot-td-context.jsonld"     = 41 bytes /
    78 37 F7            FC 24 323A383434342F...6F6E6C64
  >                                               / -> 308 bytes of contents /
])

  for a 2+1+220+1+3+308 = 535 bytes total, which could be reduced to 529 by
  eliminating three FC xx codes (left for demonstration).

  #### Explanation of selected moments in this example

  Let's see for first items of atoms table (there is single table in CBAR
  instead of shared/argument split):

  #6.10([                                                         / 2 bytes /
    /atoms/[                                                      / 1 byte  /
      "rgbValue",   #6.10(#2.11 C0 "Red"),  #6.10(#2.13 C0 "Green"),
    / #0 (9 bytes)  #1 (CA 4B C0 52 65 64)  #2 (8 bytes)         = 23 bytes /

  here you see for index #1 bytes in parentheses corresponding to string
  "rgbValueRed" - the #6.10 tag is 0xCA, then 0x4B is CBOR's Major Type 2 of
  lenth 11 - that's what "rgbValueRed" will have in uncompressed form. Then
  0xC0 refers to Atom 0 - like `simple(0)` for cbor-packed would be. It is
  taken, then 0x52 0x65 0x64 are ASCII for "Red" - here is trick for IN_BLOB
  state each byte not being a command just means itself. The "correct" sequence
  would be FC 03 52 65 64 - FC for "copy literal", then 03 bytes, then bytes
  themselves - but here we trade off speed (going i++ byte-by-byte) for size,
  saving 2 bytes.

    #6.10(#2.12 C0 "Blue"), "http://192.168.1.10",
  / #3 (7 bytes)            #4 (20 bytes)                         = 27 bytes /

    #6.10(#2.35 F7 "3:8445/wot/thing")), #6.10(#2.42 F8 "/MyLED/"),
  / #5 (CA 58 23 F7 ..-> 20 bytes )      #6 (CA 58 3A F8 ..-> 11 bytes) = 31 /

  Atom 4 (`simple(4)` for cbor-packed) is encoded as 0xF7 while IN_BLOB state,
  other is same: 0x58 0x23 is just CBOR Major Type 2 for 35 bytes, but it's not
  interpreted as CBOR because state is IN_BLOB - so here it is those "just
  template in a bytestream".

    "name", "@type",  "links",  "href",   "mediaType", "application/json",
  / #7 (5 b) #8 (5 b)  #9 (6 b)  #10 (5 b)  #11 (10 b)  #12 (17 b)    = 48 b /

  everything is simple here.

    "outputData",   "valueType",    "type",        "writable",
  / #13 (11 bytes)  #14 (10 bytes)  #15 (5 bytes)  #16 (9 bytes)   = 35 bytes/

    #6.10(#6.63(#2.18 "outputData": { "valueType": { "type": "number" } } )),
  / #17 (CA D83F 52 6A FD0D A1 49 FD0E A1 44 FD0F 46 6E756D626572 -> 22 b) /

  Here more interesting entry. #6.63 after #6.10 switches to IN_CBOR state (and
  enables consistency checking if decoder implements it). CA D83F 52 is just
  both tags and start of bstr where all following lives. 0x6A is
  for CBOR Major Type 3 of length 10. Then 0xFD 0x0D tells
  to do Atom 0x0d, that is, "outputData" at index 13 decimal. 0xA1 is usual CBOR
  Map of one pair for outer {}, then 0x49 is string in which Atom 0x0E expands
  to "valueType", inner 0xA1 map, "type" by Atom 0x0F=15, and finally "number"
  goes as is in CBOR, with it's 0x46 leading byte and ASCII ones.

  Now, final CBOR document wrappend in one 308-byte bstr:

  /CBAR/#2.308<                                                  / = 3 bytes /
  / { "name": "MyLED",       "interactions":              [      / 9+13+1    /
    A6 7C 07   65 4D794C4544  6C 696E746572616374696F6E73 86     / = 23 bytes/

  / {  "links": [  {  "href": "http://192.../rgbValueRed"         = 11 bytes /
    A5 7C 09    81 A2 7C 0A   78 35 F9       C1

  Note that it uses the same code already shown for atom table setup entries
  above - just that, by definition, here decoder starts IN_CBOR state without
  explicit tagging. And in this state set of opcodes differs, extending standard
  CBOR ones: e.g. 0x7C is like 0x78..0x7B of standard CBOR, but means "convert
  to such string value of that atom" - atom 7 in our case. As length of Atom is
  known because value is known - "name" has length 4, so 0x64 and ASCII "name"
  will be decoded.

  Final element on this quote demonstrate IN_CBOR/IN_BLOB state switching. After
  decoding you'll get "http://192.168.1.103:8445/wot/thing/MyLED/rgbValueRed" -
  this is 0x35 bytes, so you see standard CBOR Major Type 3's 0x78 35 beginning
  here. Now, decoder understands this is CBOR string and initializes
  `remaining_bytes` variable to 0x35, going to IN_BLOB state. Here it sees 0xF9
  meaning Atom 6 - which expands to "http://192.168.1.103:8445/wot/thing/MyLED/"
  and `remaining_bytes` is decremented by it's length. Now 0xC1 means Atom 1,
  also decrements variable - it reaches 0, so decoder switches again to IN_CBOR
  state. And so on...

TODO non-high-compression but "encoder-implementation-friendly" variant for at
most 1 atom per string (repeated strings only), with additional LZ pass
- and with full form dict

TBD 20.12.24 another variant tag 0xFC Fast Compressable: strings have VarInt64
instead of contents, which is moved to separate strings section, where used as
offset into it, with offset threshold to be possible to `mmap()` common
dictionary on many documents; or VarInt64 may be other identificator, e.g.
`rowid` of text/BLOB in database where this document resides

for map merging, tag 63 Encoded CBOR Sequence may be used,
cbor-records 57342-57599 also instead of tag 114
- 24.01.25 Alan DeKok suggests both may be used, not quite replacement

TODO atoms length < 3 prohibited -> integers < 256 to splice are array numbers
  - just list as (* opcode => ?argument), e.g.
    ['@'=>1, '@'=>2, '{', '!'=> [], ..., CBAR, ? checksum]
    with atomarr being just common case of dict from scratch
    - here '{' have no args - generalize to chars > 64 ?

  ## Full form of dictionary setup

  Here array is processed sequentially - an operation folllowed by it's
  arguments and possibly return value, then followed by another operation,
  etc. As CBAR is for compression, operations - essentially method calls or
  functions - are single-character strings. However, in this specification
  they are usually referred by meaningful names, not just mnemonics.

  Note that operations MUST be single-byte string, and for codes in
  ASCII range text strings MUST be treated equivalent to binary strings (major
  type ignored). Codes 128-255 are, of course, allowed only in binary strings,
  not UTF-8 ones.

  Rationale: single byte allows to save additional byte (0x41/0x61) in
             application protocols which set up dictionaries themselves.
	     Equivalence of text/binary is for more handy diagnostic notation
	     and languages/libraries where it could be more comfortable to
	     prefer one variant over another.

  Operation for dictionary setup in decoder is as follows. At start of array,
  temporary variable space is created, which could be viewed as array of
  arrays: there are variables numbered from 0 to maximum possible 255
  (implementation may impose lower constraints), each being array of CBOR
  values. At end of dictionary array, all variables (arrays) except 0 are
  discarded, and variable 0 becomes dictionary array. This dictionary array
  is then processed from start to end exactly as in the simple form, expanding
  tagged with #6.10 values to final byte string, as usual.

  The variables in paragraph above are explicit, visible to entity providing
  instructions in dictionary setup array. Decoder, of course, will have other
  internal variables, such as lengths of arrays or integer indexes at arrays.

  Rationale: it could be possible to define processing without explicit
             variables, in a functional style - using somewhat like an AST of
	     function calls. However, this would require recursion support in
	     decoder and can be difficult to express by automated encoders,
	     not when dictionary transformation is constructed manually.
	     While one can argue that dictionary scoping is also somewhat
	     recursive, it requires just one more internal array variable from
	     decoder (and index on it), implementable with same data
	     structures as all other (CBOR) arrays.

  To save a byte in outer array (that is tagged with #6.10) in common case,
  more than one argument is wrapped in array itself, and possible return
  value(s) are after arguments, e.g.

    func-name (arguments) -> (where-to-assign)

  becomes

    'x', [+ arguments], where-to-assign

  e.g. for function `splice()` assigning return value to variable 5 (array 5):

    ..., '!', [1, 2, 3, 4], 5, ...

  If return value is to be discarded (as `(void)func(...)` in C), then CBOR
  `null` is used instead. Some functions do not have return value, in such
  case they occupy just two elements in outer array, if have arguments, or may
  be just function name, if no arguments are possible at all.

  Debatable: is it needed to encode number of arguments/return to function
             name somehow (e.g. let characters with ASCII code > 64 having no
	     arguments) or we don't need it? It's arguable that if decoder
	     cannot understand unknown function (from future revision), then
	     it cannot just skip it without harming correctness.

  Below are descriptions of allowed functions. At the start of processing
  outer temporary array is empty, e.g. even variable 0 is not assigned yet.

  "LIST" below means any number of array entries, including empty. Arguments
  in list that are integers less than 256 are references to variables - e.g.
  a whole array contents may be substituted.

  Descriptions are given as if copies are made, implementations are free to
  use optimization techniques like copy-on-write, however.

  For examples below, dictionary referenced by 12345678 is assumed to have
  contents ["A","B","C","D","E","F","G","H"].

  ### Function '@' - import() dictionary

  Mnemonic: operate AT copy of referenced dictionary.

  Return value: no.

  Functional description:

       import DICT-REF
               Places a copy of dictionary referenced by sole argument to the
	       highest unused variable, e.g. at the very start it will be put
	       in variable (array) 0, if after that immediately follows another
	       import(), result will be put in variable 1, and so on. Note that
	       index of result is determined by solely size of outer array
	       (i.e. a this is a push() operation).

	       If argument is tagged with Tag 10, then value of corresponding
	       atom is substituted to obtain actual argument.

  Example:

      ['@', 12345678, '@', #6.32("http://192.168.1.1:8443/main.dict"), ...]

    copy contents of dictionary identified by application-specific number
    12345678 to variable 0 and dictionary identified by URL into variable 1.

  ### Function '!' - splice() an array

  Mnemonic: change contents of variables like in `diff -c` utility output.

  Return value: yes.

  Functional description:

       splice ARRAY,OFFSET,LENGTH,LIST
       splice ARRAY,OFFSET,LENGTH
       splice ARRAY,OFFSET
       splice ARRAY
               Removes the elements designated by OFFSET and LENGTH from an
               array, and replaces them with the elements of LIST, if any.  If
               return value is not null, put into that variable number the
	       elements removed from the array. The array grows or shrinks as
               necessary.  If OFFSET is negative then it starts that far from
               the end of the array.  If LENGTH is omitted, removes everything
               from OFFSET onward.  If LENGTH is negative, removes the
               elements from OFFSET onward except for -LENGTH elements at the
               end of the array.  If both OFFSET and LENGTH are omitted,
               removes everything.  If OFFSET is past the end of the array and
               a LENGTH was provided, decoder SHOULD issue a warning, and
	       splices at the end of the array.

               The following equivalences hold (assuming "llength(a) > i" )

                   push(a,x,y)         splice(a,llength(a),0,x,y)
                   pop(a)              splice(a,-1)
                   shift(a)            splice(a,0,1)
                   unshift(a,x,y)      splice(a,0,0,x,y)
                   a[i] = y            splice(a,i,1,y)

  Example 1 (like [draft-amsuess-cbor-packed-shuffle]):

    Let's have table A B C D E F G H in variable 0 and desired transformation
    of it to be B E F G A C D H.

    We could do this (in theory and calling array "a") as:

      splice(a,0,0,splice(a,1,1)); splice(a,1,0,splice(a,4,3));

    but our calls are linear only, so we use temporary variables 1 and 2:

      t1 = splice(a,1,1);  /* a is now A C D E F G H, t1 is now B */
      splice(a,0,0,t1);    /* a is now B A C D E F G H */
      t2 = splice(a,4,3);  /* a is now B A C D H, t2 is now E F G */
      splice(a,1,0,t2);    /* t2 is pasted after B */

    In reality we operate on variable numbers, not names, so final CBOR
    fragment will look like:

      [
        ..., /somehow we got A B C D E F G H in var 0 at this point/
	'!', [0, 1, 1], 1,
	'!', [0, 1, 1, 1], null,
	'!', [0, 4, 3], 2,
	'!', [0, 1, 0, 2], null,
	...
      ]

  Example 2:

    Let's have A B C D in variable 0 and "foo" "bar" "baz" in variable 1.
    Then:

      [
        ...,
	'!', [0, 1, 2, "Hello", 1, "world"], null
	...
      ]

    sets variable 0 to ["A","Hello", "foo", "bar", "baz", "world", "D"]

TBD 04.02.25 stack machine with 'pushmark'? so just one form of dict setup and
CBAR-rump being always last?  30 bytes in example 1 vs 27 bytes of:
  [..., '(',0,0, '(',0,1,1,'!', '!', '(',0,1,0, '(',0,4,3,'!', '!', ...]


  ### Function '#' - fill() array with null's

  Mnemonic: change number of elements in array.

  Return value: no.

  Functional description:

       fill ARRAY, NEWMAX
               Makes specified array variable have it's last index be NEWMAX,
	       or speaking possible implementation low-level C words, make
	       `realloc()` for array variable to hold NEWMAX+1 pointers to
	       elements. If NEWMAX is less than current array's last index,
	       array is trimmed (shorter encoding than splice() for offset as
	       there is no return value). If NEWMAX is greater than current
	       last index, then fill newly added elements with null values
	       (splice() is not allowed to silently create gaps as this is
	       likely error in input data).

  Example 1:

      ['@', 12345678, '#', 0, 1 ...]

    variable 0 now has contents ["A","B"].

  Example 2 (note it is invalid due to numbers - for easy counting and
  illustration to fit page width):

      ['!', [0,0,0, 1,2,3], '#', 0, 10, '!', [0,10,0,5,6,7], null, ...]

    first splice() setups array 0 to be [1,2,3], then fill() makes it 11
    elements long, second splice() inserts 3 elements at index 10, so finally
    variable 0 has contents:

      [1, 2, 3, null, null, null, null, null, null, null, 5, 6, 7, null]

  ### Function ':' - store() dictionary for later use

  Mnemonic: name and value separator in JSON.

  Return value: no.

  Functional description:

       store DICT-REF
               Store resulting (after finishing processing) dictionary under
	       this dictionary reference, so that it could be used by decoder
	       later when such reference will appear in import() function.

	       Note that multiple occurences, with different references, are
	       allowed - same dictionary may be known by different names.

	       DICT-REF here MUST NOT refer to CBAR scope stack, only user
	       values are allowed.

	       If argument is tagged with Tag 10, then value of corresponding
	       atom is substituted to obtain actual argument.

  Example:

      ['!', [0,0,0,"A","B","C","D","E","F","G","H"], null, ':', 12345678, ...]

    variable 0 is populated from scratch by splice() function, no more actions
    (similar to simple form) and A B C D E F G H array will be known under
    12345678 reference for possible later use.

  ### Function '{' - enter() new dictionary scope ("stack frame")

  Mnemonic: open brace of function in Bourne Shell and C-like languages.

  Return value: no.

  Functional description:

       enter
               Remember the dictionary that was "upper in stack" and restore
	       it when current CBOR structural element finishes, e.g. when
	       matching "}" or "]" would be seen in diagnostic notation. Does
	       not affect the dictionary currently being built (temporary
	       variables) in any way except marking it to be thrown away at
	       the end of current block (except if store() function will store
	       another copy).

TBD what about scoping to end of current CBOR Sequence / top-level?

TBD possible problem is that, by default, without scoping dictionary is just
redefined "later in stream" - is it indended? arguably yes, because
alternative with scoping exists
- but what if one dictionary defined scoping and later did not?

TBD a way in DICT-REF to refer some variable? e.g. an API call sets
a var in decoder to some Message-Id before each message, then it may be used
for store() and import() like a template mechanism?
- mb bad idea

TBD 07.01.25 some values for dict-ref to be well-known (Standards Action)
dictionaries? e.g. those which will include "@context" etc. atoms?
- half-float: dict in mantissa, it's version in exponent (then for what sign?
  private?)
  - 09.01.25 23:40 may be also with float and double: mantissa as organization
    id, exponent as dictionary id; or if private (sign), then dict id mantissa
    and exponent version; use only "normal" numbers (no Inf/NaNs); math.h has
    ldexp(), frexp(), ilogb(), scalbn() possibly usable for extracting

   The "enterpriseId" parameter MUST be a 'SMI Network Management
   Private Enterprise Code', maintained by IANA, whose prefix is
   iso.org.dod.internet.private.enterprise (1.3.6.1.4.1).  The number
   that follows MUST be unique and MUST be registered with IANA as per
   RFC 2578 [RFC2578].  An enterprise is only authorized to assign

TBD 15.01.25 there is Tag 112 relative to 1.3.6.1.4.1

TBD recursion problem (nested CBAR after unpacking bytestr) - a tree of dicts?
- or better prohibit recursion at all in favor of scoping? as it requires
  additional memory and tree of dicts is too complex

TODO examples to DICT-REF:
   For example, in [IANA.cose] SHA-256 has the COSE algorithm identifier
   -16.  This is in the range -256 .. 255 (inclusive range).  Therefore,
   tag 18540 (= 18556 + (-16)) is the tag for a byte string containing a
   SHA-256 hash.



  ### Function '^' - zdict() for two-phases compression

  Mnemonic: to upper phase and ^ similar to letter 'z' of zip/zlib/zstd/etc.

  Return value: no.

  inflateSetDictionary()


TBD 06.01.25 for nested scopes, it may be beneficail to use tag #6.10 on just
individual elements, e.g. strings, but #6.10(tstr) will likely produce invalid
CBOR - so a way to say "it's text string with MULTIPLE atoms inside", as for
single atom there is #6.10(uint)
- this is already possible with e.g. 7A LL inside, but will require tag 24 to
  enable IN_CBOR state, so it's at least 3+L byte overhead in comparison to bstr
- not quite, outer length is not equal to inner length for multiple atoms

TBD 07.01.25 in nested, only leaf could be complete #6.10([dict, bstr]), outer
forced to individual elements and sequences - what if allow CBAR element to be
actual CBOR instead of bstr for middle scopes? akin to 256() namespaces
- so untagged map/array let's be just CBOR, otherwise it's compression
  - what for types which have tag on outer level? use 22098 ? and
    22098(22098(...)) if it was really 22098 ?

TBD 07.01.25 morn thinking process: Tag #6.10 is like $var in POSIX shell,
recursion is like `eval` in shell, generalize it to Tcl `{}` as FC copy for
recursion prepended by command? or better have `apply()` function and set up
dictionaries at once, then use them via 128 Alternatives Tags, and use FE code
with VarInt where values are same as in 128 Alternatives Tags
- 09.01.25 23:10 for apply(), use codes 128..255 as dictionary+128 for
  Alternatives Tags ('=' may be used as for 'current' without argument);
  #6.10(#6.alternative(array)) may be used as a namespace for arrays (instead
  of dictionary setup)
  - 10.01 02:27 what if uncompressed CBOR element also had Alternatives Tag on
    it? repeat #6.10 again as a "stop code" ? consume only one Alternatives
    Tag when having two (second of value itself) ? or just throw this problem
    away to simplify spec, as bytestring variant is always available?
    - 10.01 20:30 Tag Substitution principle dictates moving such tag out:
      for dictionary 2 == Alternative Tag 123, compressed and uncompressed:

        #6.121(#6.10(#6.123({"key": value}))) == #6.121({"key": value})

  - 10.01 03:17 where to reset Alternatives dictionaries? if all dictionaries
    were set up in one CBOR Sequence in a manner import(ref1), apply(),
    import(ref2), apply() then it is for next sequence so useless to have
    "one CBOR sequence" scope... have a nextmessage() method in decoder for
    message boundaries? `$cbor->incr_reset`

TBD 07.01.25 better for CBAR element for "later in stream" to be always
substituted - use tag #6.31(undefined) to cut completely?

TBD 16.01.25 functions '1'..'9' for byte compression params (match Septinovile)

TBD 24.01.25 letter functions for extensions, big (capital) with return value
and small (lower case) when no return value - e.g. [draft-dns-cbor] needs
custom adding for all suffixes; also allow 2 bytes for "spec required" and 3+
for FCFS but MUST NOT be usable outside of CBOR - single-byte are for lower
layer application protocols when it's not only CBOR; so e.g. "nc",N from
[draft-dns-cbor] may define CBAR member must not be a bytestring but real CBOR
where strings are counted and added with all their suffixes as CBOR sequences
to dictionary N

  ### Function '0' - reset()

  Mnemonic: zero out everything

  Return value: no.

  Functional description:

       reset 
               Removes all numbered dictionaries and all temporary variables.

  ### Functions 128-255 - apply() to dictionary number

  These are special in that they contain argument in code itself: it means
  take current set of temporary variables and save them in temporary
  dictionary N, where N=code-128. These dictionaries are later used by
  Extended Functions or Alternatives Tags - there are exactly 128 alternatives
  tags taking "any" data item, perfectly matching high range of 8-bit byte.

TODO

  Appendix C. Compress::LZF

TODO

  # Appendix D. Example of application-defined function, on DNS example.

  Function "nc" takes one argument - dictionary number where to place scanned
  strings. It is needed to correctly distinguish references to built
  dictionary - e.g. to use only #6.10(#6.123(uint)) references if the
  dictionary selected is number 3, leaving other dictionaries for possible other
  packing tables. First CBAR-rump element, which, when this function is present,
  MUST be CBOR and not a bstr (though some elements, excluded from this, may
  be #6.10(bstr)'s), is scanned to build dictionary which number specified in
  argument. Then, in second pass, CBAR-rump element is unpacked as usual (or
  accessed in-place without intermediate buffer, if particular implementation
  allows it).

TODO more description

  Take the following CBOR object _o_ (note that this is intentionally not
  legal "application/dns+cbor" to illustrate generality).

  [
    ["www", "example", "org"],
    ["svc", "www", "example", "org"],
    ["org", "example", "org"], 42,
    ["svc", "www", "example", "org"], 42
  ]

  This would generate the following dictionary _V_ with CBOR Sequences,
  depicted arbitrarily in human form, as EDN does not support CBAR yet:

    0: "www", "example", "org"
    1: "example", "org"
    2: "org",
    3: "svc", Atom 0
    4: "org", "example", "org"

  e.g. for index 0 really #6.10(#6.63(bstr)) with bstr wrapping 3 strings in
  it, or CA D83F 4F 63 777777 67 6578616D70 6C 65 63 6F7267 in binary,
  and for index 3 it is CA D83F 45 63 737663 1D (tag 63 enables IN_CBOR state,
  so Atom 0 is 0x1D here)

  Note that the sequence "org", "example", "org" is added at index 4 with
  leading "org", instead of referencing index 2 + index 1, as it is its own
  distinct suffix sequence.

  The packed representation of _o_ would thus be:

  10(
    [
      "nc", 0,
      [/CBAR/
        ["www", "example", "org"],
        ["svc", 10(63(0))],
        ["org", 10(63(1))], 42,
        [10(63(3))], 42
      ]
    ]
  )

NOTE that "MUST be CBOR" requirement for CBAR-rump limits effectiveness of
compressing common IPv6 address parts: suppose Atom 6 has value of 11 zero
bytes, then original 17-byte bstr for address 2001:db8::1

    h'20010db8000000000000000000000001'

will become

    10(h'2001 0db8 F9 01')

or 8 bytes CA 66 2001 0DB8 F9 01, while in bstr-wrapped CBAR-rump it could
have been 7 bytes - tag omitted.

TODO NB! requires standardizing that #6.10(#6.63(uint)) inside array "splice"
elements of sequence into it, so array size grows and differs from original;
also MUST prohibit such usage outside of arrays!
- 02.02.25 problem of #6.10(#6.63(bstr)) in atoms definition - it does not
  expand to sequence (of atoms) here, it's intended (currently) be still
  bytestring! need to clarify

TBD 03.02.25 what about "macro" function (for DNS generalizing): just
substitute a sequence of functions from known place to shorten dictionary
setup - do it need arguments? mb look at Template::Toolkit?

TBD 04.02.25 where in https://www.w3.org/TR/json-ld/ for nested
contexts? example 47 ?
TBD 05.02.25 composability: stack of dictionaries? like x87 or register window?
- no, just stack frames, negative (-1-N) refers to upper frame's dictionaries
  - need for splice() to be read only on them, then
  - no point in "no cut - copy only" splice() on usual dict - for compression
    atoms shouldn't repeat
- 06.02.25 be that number 128*level+dict (7 low bits) for >1 stack frame
- 06.02.25 allow splice() on argument stack itself! false/true for cut/copy
  (readonly or not)
- 06.02.25 allow array for argument list as it it is 1 byte for <24 than '('?
  - or make mark null/undefined?
- 06.02.25 simple(0)..simple(19) could be used instead of h'80'..h'93' with
  note that this meaning only in dictionary setup array but not below it, e.g.
  application's simple(0) will have meaing of that application
  - 08.02 15:09 use only simple(0..6) to match Alternatives tags, others for
    most used functions, and make them abbreviations/macros: e.g. simple(1) as
    assignment to dict 1 is it's clearing and then using arguments:
    '(', '(', 1, 0, 1,'llength', 'splice', ')'
    - incorrect prog, offset/length must be before our list on stack...
      - need function 'unshift_arg' to move top-of-stack (including '(') right
        after '(', so:
        1, 'llength', 'ua', 0, 'ua', 1, 'ua', '(', 'ua', 'splice'
    - allow some simple(N) be defined by tag/media type, e.g. for DNS, and it
      can be just 'tag:ietf.org,2025-02:lenders/dns-cbor', 'mr' ("macro run")...
      - and may be [number/letter, +commands], 'md' for macro define?
        - this requires storage for macros... optional for constrained?
- 06.02 need #6.10(#6.122(uint)) on arguments to import() and store() - to
  pass from client to server dictionary URL only one time in dictionary 1,
  then query if server has them and uploading with store() if not
  - see 15-18.02.25 for alternatives '$'/'@'/unwrap() then 'ld'; we'd better
    limit use of #6.10, especially in combinations, to pure CBOR, not in
    commands
- 07.02 03:00 we can add some flow control without complex stack, e.g.
  "foreach" can take two arrays as arguments, `list` and `body`:

  [..., ["www", "example", "org"], [cmdX, cmdY, cmdZ], 'foreach', ...]

  and in simplest implementation splice()'s command list to be

  [..., "www", cmdX, cmdY, cmdZ,
        "example", cmdX, cmdY, cmdZ,
	"org", cmdX, cmdY, cmdZ,
   ...]

   of course, implementations are free to apply whatever optimizations they
   want to avoid allocating too much memory, e.g. make it real loop with
   a counter (however this may become complex on nested constructs)

   for one label set:

   "",
   [/foreach body on "org"/      /S: "" "org"/
     'ts',                       /S: "" #3.3("org") - convert to tstr        /
     'swap'                      /S: #3.3("org") ""                          /
     '.',                        /S: #3.3("org") - concatenated              /
     'dup',                      /S: #3.3("org") #3.3("org")                 /
     '(',                        /S: #3.3("org") #3.3("org") '('             /
     'swap',                     /S: #3.3("org") '(' #3.3("org")             /
     0, 'swap',                  /S: #3.3("org") '(' 0 #3.3("org")           /
     'unshift',                  /S: #3.3("org") dict[0][0]: #3.3("org")     /
   ],
   [/foreach body on "example"/  /S: #3.3("org") "example"                   /
     'ts',                       /S: #3.3("org") #3.7("example") - to tstr   /
     'swap',                     /S: #3.7("example") #3.3("org")             /
     '.',                        /S: <#3.7("example")#3.3("org")> - concated /
     'dup',                      /S: <gexamplecorg> <gexamplecorg>           /
     '(',                        /S: <gexamplecorg> <gexamplecorg> '('       /
     'swap',                     /S: <gexamplecorg> '(' <gexamplecorg>       /
     0, 'swap',                  /S: <gexamplecorg> '(' 0 <gexamplecorg>     /
     'unshift',                  /S: <gexamplecorg> dict[0][0]: <gexamplecorg>/
   ],                            /                  dict[0][1]: #3.3("org")  /
   [.../same on "www" leads to <cwwwgexamplecorg> in stack & dict[0][0] / ],

TBD 07.02 05:35 if make push/unshift only one arg, then possible to eliminate
'swap', 0, 'swap'
- inside macro it is not a real problem...
- 18.02.25 here assumed that <<0, 'unshift'>> operates on dictionary 0, but in
  variable tree that would be 121 - should we fix it? in macro growing of size
  is not a problem, but "path" vs ["path"] is to be thought

TBD 07.02 05:40 need to modify prog above for:
1) independent domains - currently it always shifts to zero
2) for <3: "svc", Atom 0> - when/where to expand atoms?
* '(', cond, [then], ?[else]?, 'if'   ...or distinct 'if'/'ifelse' so no '(' ?
* 'is_single_atom' ('?'+h'1A') - if arg consists solely of one atom

   [/inner foreach body on "svc" or Atom 0/
     'dup',
     'is_single_atom',
     [/true/
       /do nothing - just leave tail atom on stack, will be concatenated     /
       /with next element on next iteration TBD non-tail atom or malformed?  /
     ],
     [/else/
       'ts',                     /S: #3.3("org") #3.7("example") - to tstr   /
       'swap',                   /S: #3.7("example") #3.3("org")             /
       '.',                      /S: <#3.7("example")#3.3("org")> - concated /
       'dup',                    /S: <gexamplecorg> <gexamplecorg>           /
       '(',                      /S: <gexamplecorg> <gexamplecorg> '('       /
       'swap',                   /S: <gexamplecorg> '(' <gexamplecorg>       /
       1, 'swap',                /S: <gexamplecorg> '(' 1 <gexamplecorg>     /
       'unshift',                /S: <gexamplecorg> dict[1][0]: <gexamplecorg>/
     ],
     'ifelse'
   ],


TBD 07.02.25 call rump "template" and make it, as well as certain arguments in
dict setup, be also compressible/references to external values - like
import()/store() and macro arguments (see notes of previous day); see also
[Yet Another Compact Time Series Data Representation Using CBOR Templates (YACTS)](https://imt-atlantique.hal.science/hal-04592891/document)
- theirs "context in the metadata" is essentially application-defined
  dictionary in CBAR e.g. with integer, for import() - so overriding by theirs
  "specific metadata" is CBAR's splice() to that dictionary with message-local
  atoms, e.g. their map {0:1 , 1: 1593982800 , 2:10 , 3:3}
  could be represented by A4 (map of 4) and four atoms following, each having
  key:value sequence; and this allows - more readable than integers - string
  keys - so CBAR is more human-friendly after unpacking
- so overall, the only their addition which can be generalized - is variable
  number of similar entries - something like [% FOREACH %] in template itself,
  e.g. $tt->process($tpl, $vars, $out) - my notes above were $vars only
- BTW, their "5.2. Tree Formatting" with `TAGN(v1, v2, ..., vn)` locating in
  nested arrays is similar to muSCTP's "sesctl" for which CBAR was born
  and to Tcl's `lindex` command
  - general template processing may benefit from unlimited variable tree, in
    contrast to current "128 dictionaries, each is just array", but that
    contradicts to packing (shortest atom representation) and simplicity
    - 08.02.25 22:20 if an element in stack is array, make `lindex` accessor
      for it in Extended Functions? in usual too? if others like `lappend`
      then this intersects with splice()...
    - 09.02 02:04 what if restrict VarUInt30 ? for FD it's already VInt21, let
      it be same until 2^21 and then - number of bytes following minus 2 (65
      max), which are list of 21-bit integers:
      0....... - 7 bits
      10...... - 14 bits
      110..... - 21 bits
      111..... - CBOR Major Type 7, Reserved for future use (like VTS)
      so this list can be used in FD, 7C etc. where atom number is needed
      - but for FC still leave it VarUInt30 ? 2 megabytes is not that much, in
        contrast to atom sizes which may require dozens of bytes per entry of
        overhead...
      - 09.02 02:40 now allow [index1, ...] as array name to splice() etc. and
        we are done! just as we did above for "example.org", prepare this tree
        from current iterator value on stack and then just with 'tp'... the
        only question now is scope/living time - when/how autodestroy them?
        - 02:49 add a bool to indexes array if splice() allowed to cut?
        - 03:26 simple: when [...] is splice()d to program, it is surrounded
          automatically by unshift() on enter and shift() on exit with
          discarding result; in atom indexes paths this is ..0, N for current
          scope, ..1, N for parent and so on; now only top index should be
          choisen for this for these "local variables"
          - may be just directly 0..120 ? complicates handling (to not disturb
            121+) compared to plain shift/unshift but saves one byte in each
            access (e.g. 7C C1 00 nn)
      - standard atoms in 128 dictionaries also can be accessed by indexes
        121..127 etc. as with Alternatives Tags so this can be cheaper than
        switch dictionaries back and forth
     - 10.02 this introduces three similar but distinct VarInt formats: for
       FC length, FD (7C, ...) atom number or array of numbers, and FE escape;
       better to unify (and higher length for FC)
       - 11.02 03:00 if declare that array can start only from integer, then
         escaped byte values may serve as array size, so will be treated
         different only by FD (which can't have array), so each element will
         be parsed uniform, just first will be special after parsing
         - 03:30 but then FC also may have array, meaningless
           - why? type of chunk may be put here, instead of separate FE, just
             check if it is not longer... and it is, FC al i1 i2 is not
             shorter than FC i1 FE i2...
             - 04:00 only if we make smth like FC C0 ll like tagged, haha
             - not "tagged", just treat as list and interpret differently:
               * for usual, special value is index to table how many read more
               * for FC, it's type and reading only one next element
         - 11.02.25 20:30 so let it be:
             0..159 values coded as themselves                     bits:
             101aaaaa bbbbbbbb                                     - 13
             1100xxxx C0..CF are special codes
             1101aaaa bbbbbbbb cccccccc                            - 20
             11100aaa bbbbbbbb cccccccc dddddddd                   - 27
             111010aa bbbbbbbb cccccccc dddddddd eeeeeeee          - 34
             11101100 aaaaaaaa bbbbbbbb cccccccc dddddddd eeeeeeee - 40
             11101101 aaaaaaaa bbbbbbbb cccccccc   ...    ffffffff - 48
             11101110 aaaaaaaa bbbbbbbb cccccccc   ...    gggggggg - 56
             11101111 aaaaaaaa bbbbbbbb cccccccc   ...    hhhhhhhh - 64
             1111xxxx F0..FF are special codes
    - 15.02.25 need templating for maps, instead of cbor-packed's cancelling
      entries with key/null's
      - fill some array in tree with key-value pairs (one per element), define
        conversion functions to generate CBOR array or CBOR map from in-tree
        array (count of elements)
        - need we define opcodes 9C and BC like 7C, or it's waste of atoms?
          - 22:34 no: as it will be several elements = path in tree (array
            reference), and CBOR arrays/maps expected to be many bytes in
            expanded form (in contrast to simple strings), one byte will not
            save much here
            - also a rule: single-bytes only for scalar types, so better think
              of 1C/3C ?..
          - may be standard FD but with a Special Value in Path Array as
            a convert function?
        - 22:56 need a construct like:
          @array = @array[1,4..6,0], @another_array, @array[2,3,7];
          - see below at 02:50 for ']'
        - 23:28 also, need we @$% in CBOR arguments for referencing Path Array
          (path in variable tree) so need tags for this - to distinguish from
          literal CBOR items in e.g. list for foreach() ?
          - 23:34 tags 64-71 can be for path array... but what if those are
            used by target application (after expand) too
            - 23:39 look at Tcl's [] and $ ?
            - 23:43 a 10(h'FD path') ? raises question of when to expand atoms
          - 16.02 01:30 no, functions '@' and '$' may be used to substitute;
            so need other mnemonic for import() and probably two distinct
            funcs: '@' for just list (splice) and '[@' (?) for wrapping as
            array (CBOR)
            - 02:50 wrapping probably better done by '[', ..., ']' (or '(' ?)
              and have '@[' for subscripts ranges? so example at 22:56 above:
              ..., '(',
                        [path,to,array], [1,[4,6],0], '@[',
                        [path,to,another_array], '@',
                        [path,to,array], [2,3,7], '@[',
                ']', 'splice' ... # TODO proper assignment
            - 05:50 is '$' same as `lindex()` ?
            - 18.02.25 20:20 a [..., 2, '$', 'ld', ...] could be used for
              loading dictionary with long string name which was pushed for us
              to Atom number 2 externally e.g. by media type, or [path,to,var]
              instead of Atom - e.g. [1,2] as first var in upper stack frame
            - 18.02.25 22:56 BTW nothing prevents argument to 'ld' be compound
              CBOR type, e.g. an array [db_name, table_name, rowid]
- 16.02.25 05:35 for reference, generalize #6.10([+ commands, template]) to
  just commands: they must leave exactly one value on (stack) S, which will be
  then examined if it is to be parsed as CBOR or bstr template (and in latter
  case continued by output() and so on) - so usual commands may dereference
  some external value just as they would do for import() dictionaries and
  leave it's fetched contents as single value on stack
  - so import() becomes lower-level than dealing with dictionary number to put
    into - it just downloads and puts contents on stack, and some other
    function must then put such array into specified dictionary (and expand
    atoms, etc.)... so use h'01' code with mnemonics as CoAP 0.01 "GET" ?
    reserve 0.02 for POST ? or better rename to fetch() as it is not only URL
    but e.g. aplication defined number 12345678 ?
    - 06:30 need unwrap() function to push contents of such imported array on
      stack to later be put into dictionary?
    - 17.02.25 call it load() 'ld' to match with store() and to load generic
      CBOR documents: be it dictionary, or macro, etc.
- 18.02.25 16:00 in Tcl `foreach` supports multiple variables and multiple
  lists in parallel, might be handy for templates like VTS or SenML or even
  MyLED example, but need to think what goes to argument stack S and what in
  variable (scope) stack
  - 18.02.25 23:24 possible solution at this timestamp above
  - 18.02.25 23:38 while 'continue' ('next') can be emulated by 'ifelse' with
    one branch empty, 'break' ('last') is not so if implemented by splice()ing
    several times into program itself... so postulate [+cmds] is child program
    with variable's stack frame? so it will also be simple to push/pop stack
    frames (no "implicitly add splice()s to prog") and to make e.g. built-in
    counters for loops
- 20.02.25 19:00 what if instead of stack make it entirely Tcl-like? e.g. it
  would be single unified #6.10([+commands]) as `[command substitution]`
  whenever it seen, returning result of (last) command, no separate
  "dictionary setup" or so, and `{script string}` is just `[cbor, array]`
  without tag (command like 'if' will use it if want)... greatly simplifies
  implementation, just need to find analog of `{*}`/`@{`/etc. and $variable
  dereference... though not much different from stack or Lisp here
  - the main reason of stack machine is compactness: we are packing, so
    10([2,'$','ld',simple(0),rump]) or 10([atom1,...,atomN,simple(0),rump])
    is quite compact - in contrast to Tag 10 plus array starter byte overhead
    for *every* function... and chaining requires nothing in Forth but at
    least ';' between commands in [same script]
    - however, the Stack compactness is not that obvious in complex cases
      where '(' and 'unshift_arg' are needed - need to write some real
      programs to compare, and see what is more often/rarely used
  - 21.02.25 15:35 looks like compactness may be solvable if:
    1) make some commands prefixes of execution of next command, like
      'nice cmd args...' in Shell,
    2) declare that some arguments are not arguments but rather commands with
       fixed number of arguments, e.g. 'ld' or '+' (however for '+' that may
       be relaxed for any number of args if in first (=command name) position)
       parsed and substituted as they are read, that is, equivalent of placing
       a call 10([fixed, number]) in it's place - after all, Tcl is not Lisp
       and also has some syntax beyond just quotes/braces/brackets... so can
       10([simple(0), 'ld', '$', 2, rump]) now with same efficiency
       - 16:10 hmm, this example has nesting, so it's either scanning from end
         of array or "inserting bytes CA 81" into CBOR representation before
         such command and then re-parsing CBOR?..
         - 23.02 will need to mark value in implementation somehow to prevent
           infinite recursion
       - extensibility: h'nA BC' for unknown commands with N arguments?
         - 16:26 why unknown, that's shall bail out? known, but optimized
           - if we are going to use macro names or 'proc', may be unknown at
             time of parsing: will be loaded from external when executed
       - 18:22 a tag to escape commands like '\' when short strings needed for
         e.g. concat() ? a generic escape 10(['process-cbor', 'ld']) could be
         too long
       - 22.02 18:30 a tag (1+1) won't be shorter than just special "\" cmd
         - 27.02 23:00 but simple(12) can (^\=0x1c, let's -0x10)
       - 23.02 there is problem with commands short by nature: 'if', 'do'...
         - 14:24 tag 21334? tstr vs bstr?
           - changing to text makes it too easy for human error, but still
             should reserve 110xxxxx 10xxxxxx to be NOT used in bstr
         - 15:00 provide command ['parse-alias', original, count, short-form]
           so that only those in list will be considered on parsing and only
           '\' and ';' will be unchangeable
           - what to do if there are too many of them? some pattern?
           - or name it 'keyword'? 'keysyllable'? 'flatten'? 'parse-syllable'?
             - 08.03.25 23:00 make parse-alias working only on non-first
               member, so e.g. '+' may have any number of arguments in first
               position and just two when flattened in arguments
               - 23:10 problem of such aliases in bodies of 'if', 'foreach'
                 etc. where there is no Tag 10 - either this should work
                 everywhere or be expicitly marked by e.g. 'process-cbor'?
                 - 15.03.25 03:35 not needed if we declare that this happens
		   for any array passed to 'eval' ('execute'?) function - for
		   Tag 10 it is done by 'process-cbor', and for command body
		   (e.g. of 'foreach') this 'eval' will be called by that
		   command, so everything becomes uniform... but it must be
		   detailed explanation that on "top" level this is called by
		   'process-cbor', but on current level for 10([cmd, arg]) it
		   is called by 'eval' itself: so command substitutions here
		   will work for 10([topcmd, arg1, 10([get-arg2]), arg3]) but
		   only on one level - so 'foreach' body here is not touched
		   as not having Tag 10 immediately on it (in fact same as in
		   Tcl, just Tcl has only strings and we have entire CBOR)
		   - 03:50 BTW 'process-cbor' need to have parse-alias (or
		     even part of syntax?) to support complex CBOR trees in
		     expressions, for example, assignments like
		     `$subdocument = {"key1":1, "k2":[0, 1, $myvar, 3]}`
		     ...this reminds Lisp quotes... but let's start that in
		     new notes thread, this one is too indented
               - 13.03.25 then need to alias '$' by other means so that
		 dynamic dispatch [$cmd args...] still could work, or make it
		 parsing exception (part of syntax) like '\' or ';'
                 - 15.03.25 03:30 huh, then same must be done for '@' as list
                   substitution ("{*}")
               - 15.03.25 03:20 btw, prohibit '\' in first position as it is
                 meaningless there?
         - 16:00 what to do if '\' in scope of flattened form?
           - similar to ['ld', '$', var] problem: '$' must be unflattened first
    3) 23.02 01:40 Jim Tcl has [alias name args...] e.g.
       `alias e info exists; if {[e var]} { ...`
  - how to code recursion of scripts efficiently? in stack machine it's very
    simple... however, some recursion in decoder is inevitable due to e.g.
    #6.10(#6.121({"nested": ["dictionary", "scope"]}))
  - 22.02.25 03:00 what if #6.10(uint) inside program is current stack frame's
    local variable reference - that is, $localvar? is it generalizable with
    same meaning for atoms in plain CBOR / inside Alternatives Tag, as e.g.
    `with ...` or `(let (...))`?
    - this is OK for single atom as variable, but for global Path Array in
      variable tree, which is like $var::in::namespace, such name will be
      [cbor, array] and Tag 10 on array already means "execute it" in this
      paradigm... also not quite good if deferred atoms evaluation will be
      chosen: when/where to expand - simple dictionary setup will want to
      first collect arguments of #6.10(bstr) form and then process them in
      a foreach loop
    - solved later by named vars (tstr)

TBD 17.02.25 all in-CBOR tags applications should be defined in terms of
applying (elementary) (stack) functions, e.g. #6.10(24(bstr)) as something
like [bstr, 'expand_CBAR', 'parse_cbor_from_bstr'] program

TBD 23.02.25 01:40 looking at Jim Tcl, it has "args" to [proc] not only at
end, and some other commands are also usable, e.g. [range], [loop]; in sources
it has Jim_EvalFrame for everything (e.g. body of [foreach] which executed by
Jim_EvalObj on C stack) and Jim_CallFrame for [proc]'s, having variables - do
we need only the latter to be explicitly available?
- 03:00 if we have #6.10(#6.121(...)) equivalent to #6.10([commands, CBOR]),
  then to access variables upper in CBOR (see notes at 05.02.25 and 06.02
  for -1-128*level+dict) still need this as eval frames?.. also a clash
  between atom numbers and $variable numbers in execution code, and also
  numbers to separate argument variables from local variables? may be to
  different array in stack, but that means always '$' [path, array] which is
  longer
  - 03:50 make different commands, e.g. 'a' to get atom instead of '$' ? and
    'l' for local vars; in fact, "in addition" (not instead) to '$' which
    still able to access everything by path... BTW this somewhat parallels FD
    code in template which can be either plain number for atom, or path array
    - 26.02.25 12:30 ok, if we use 'a' for atoms and [proc] to define which
      args go to which local variable, then no need in separate argv access,
      so '$' with single number refers to local variable - but what if that
      variable is array? how to access it's members - always full path?
  - 25.02.25 17:45 define such tag expansions in terms of built-in [proc]'s,
    not C functions - thus they will have CallFrame, so no need to track every
    eval frame
  - 26.02.25 01:13 it would be very comfortable to have named variables, but
    this requires a map (ususally hash table) in implementation which is not
    good for constrained implementations, but more seriously, again a change
    in VarInt or it's array to have strings - but what if apply idea of atoms
    here again?! e.g. write with variable names and have a table to which
    numbers they are transformed on "compile"
    - won't work as-is: atoms are about restoring strings, and will need to
      have #6.10(uint) - not compact, opposite direction...
    - 26.02.25 10:30 no need: compilers and assemblers have numbers only and
      separate debug sections; in simplest case can use #define VARNAME 0 and
      pass diagnostic notation via C preprocessor first; may define command
      e.g. 'de' with single argument ignored on execution and containing
      debug/description info
      - 27.02.25 22:00 see entry at this time below of two classes
  - 26.02.25 12:56 this means having separate set of dictionaries in *each*
    CallFrame for document composability! even in [proc]'s where it's not
    needed! So again problem of what format stack frame has
    - 23:58 declare many commands, including simple(0), that they mark current
      CallFrame as new DictFrame, so that several such commands in a row in one
      10([...]) will not create additional frames; new DictFrame is initially
      empty and each DictFrame consists of 128 arrays (one per dictionary)
      - 27.02 01:20 or the mark must be still in EvalFrame ?...
        - 01:26 we need it in CBOR, may be magic in 'process-cbor' func?
          anyway, it depends on the semantics of dictionary-writing commands
          - 19:00 yes, let's recall how it was looking before interpreter:
            #6.10([...]) was always for dictionary setup, and it is so
            *in CBOR*, and expansions of #6.10(#6.121(etc)) also happen only
            in CBOR, thus no need to change EvalFrame: CBOR is always
            processed by 'process-cbor' lower-level built-in (which should be
            exported as decoder's object method), even at top level where
            interpreter wasn't ever called on this message yet - so this
            processor can see if #6.10([...]) has no #6.10([...]) parent in
            CBOR meaning it's dict setup, so implicitly "prepends" to it
            'push-dict', ';' call, if we want to also provide explicit control
            on dictionary stack for user, or does it entirely in C (or mixed
            variant, where only 'unpush-dict' is available to user)

TBD 23.02.25 14:00 pack/unpack functions: to be able to pass a compacted BLOB
with a schema identifier to be transformed to/from CBOR: so that CBOR can now
compete with more compact schema-based serialization like Protocol Buffers
- need some way to exchange supported features of encoder/decoder: pack/unpack
  have subtle differences between languages/implementations (Jim, Perl,
  Python, Tcl) so list of keywords and each may be with some description

Rivet https://chiselapp.com/user/rkeene/repository/xvfs/file?name=lib/xvfs/xvfs.c.rvt&ci=tip

set dict0 ""; set y ""; foreach x {org example www} {set y |$x$y; set dict0 [linsert $dict0 0 $y]}; puts $dict0

  [...,
    'set', 0, "", ';'                         /var 0 as accumulator/
    'foreach', 1,                             /variable 1 will be loop variable/
    10(['reverse', "www", "example", "org"]), /TBD/
    [                                         /foreach body/
      'set', 0, 10(['strconcat',
                     10(['to_tstr', '$', 1])
                     '$', 0
                   ]),
      ';',                                    /separator/
      'unshift', [121], '$', 0                /TBD be dict[0] in 121?/
    ]

  ]

TBD 24.02.25 01:30 what about template? code clearly need access to output()
function, which may be unique per each code generator instance, but that is
solvable by e.g. implicit parsing alias to short name like '.='; however, what
is the best way to put CBOR code blocks in template? introduce third state
IN_CODE (or rename all them like INPUT_IS_CODE?) switched off by again some
byte code invalid in current CBOR? This is in spirit of <? ?> tags, where
standard IN_CBOR->IN_BLOB switch on e.g. 78 1E is like <?= ?> tags. Advantage
of such "indefinite-length" switching is that it makes impossible to break in
middle of CBOR-code element by specifying incorrect length to FC, and also is
shorter on larger lengths than FC xx yy (and even shorter, as FC needs to be
typed (have type prefix byte), or else length need to be encoded to FE somehow)
but what to do with lengths of CBOR array in code? Make special FE xx code to
switch to IN_CODE and then back just for 1 byte - FF indefinite-length CBOR
termiantor? Also seems there is no need for big number of Extended Functions
as they could be enabled by just CBOR code (well, only if to have shorter
encoding for some, like dictionary switch) so VarInt22/VarElem format need to
be reconsidered again? it's tempting for '$', [...] make real CBOR array here
(as in <?= $var ?> shortly switches to code also just for one arg) to avoid
redesigning format again in future if need will arise - ideally we must have
only one non-CBOR VarInt format for simplicity, and newer VarElem to this
date (11.02.25 20:30 version) is not so simple as things were in December
- 02:40 for one-shot dictionary switch need just two numbers, and this can be
  done by e.g. limiting atom to 32 bits then taking low and high halfs.. but
  for pairs like (126,126) it's too much overhead
- 14:46 make use of FD < 16: 2 bits for convert type, 2 bits array len
  - but there are only 9 atoms in IN_BLOB
    - 25.02.25 17:45 make one bit "additional VarInt for conversion function"
      and it's format is two bytes which would be string payload, so
      one-letter ASCII will fit in one byte (so 'tstr' and 'bstr' likely be
      't' and 'b' by default), thus any function can be assigned by parsing
      aliases, not only CBOR - good for generic BLOBs... also array limited
      from 2 to 5 members does not limit variable tree depth, just accesible
      in short form from template
    - 05.03.25 13:23 if we'll go variable tree "unified CBOR document" way
      with character strings in VarElem, then use e.g. 0xF0..F3 codes for
      conversion, and then it looks like enough depth of 9 for IN_BLOB mode
      but 16 for IN_CBOR mode as CBOR sub-documents in variables may have more
      depth; and if not, may be optionally provide 'tp' ('template-process')
      with root variable for such paths?
      - 06.03.25 17:09 yes, let's go this unified document way, see also this
        datetime below
    - 05.04.24 02:00 we can define that FD 0x < 9 is treated as if it was
      10([_x CBOR]) instead of VarElem array so that *any* [conversion]
      function can be called here, without dealing with bits, and it even will
      be reasonably short with proper 'parse-alias' and may even have more
      arguments by nested 10(['echo', args...]) than limit of 9... this would
      be good analog of <?= ?> but can it also replace IN_CODE totally?

TBD 27.02.25 22:00 about wanted variables as non-numbers but strings: let's have
two classes of decoders, constrained and full, and even describe them in spec
in separate chapters: so constrained has no local variables and is limited to
VarInt start byte < 0xC0 and static template so can be decoded in-place; and
full implementation may have IN_CODE state and named variables - 0xC0..CF be
strings ("character"), and full implementation can affors to have hashtables
for maps. Then only thing to solve here is Path Array in Variable Tree: what
if some level wants both array and map, e.g. 'var' and $1 ? In Tcl they just
have maps (strings) always... CBOR maps allow to have distinct '1' and 1 keys,
but this is unfriendly to implementations... this reminds sesctl() !

TBD 04.03.25 17:35 as CBAPT, it may be further extended to be used as
an alternative to https://capnproto.org/rpc.html for multi-method calls on
high-latency links (e.g. MQTT5-like and/or for environments when Cap’n Proto
itself is not applicable, e.g. no direct connections) - for this, should look
to `jq` utility for needed features, so let's read it's manual and comment:
- `.[]` is like `@$...`
- array & object construction: `[.user, .projects[]]` need 'process-cbor'
  here? but in `jq` input `{user, title: .titles[]}` produces two outputs:
      {"user":"stedolan", "title": "JQ Primer"}
      {"user":"stedolan", "title": "More JQ"}
  - our `foreach` and `lmap` can do, someone can do higher-level syntax
    compiling to CBAPT if they want
- for array concatenation and object (hash/map) merging better special
  functions than `jq`'s overload of `+` or `*` for recursive merge
- overload of `length` is also doubtful (so they added `utf8bytelength`)
- `pick` description WTF?..
- `getpath` and `setpath` are in spirit of last weeks notes...
- `select` is `grep`, `any` and `all` - use others from List::Util? e.g. they
  have `reduce`
- `flatten` discussed weeks above, here it can take levels
- `sort`: use CBOR encoding for sorting? so numbers first, `undefined` last?
  then negatives are unnatural... may be make exception for them
- `min_by` etc: use generic `sort` with code block
- `indices`, `inside`, `endswith` and `startswith` are ad-hoc versions
- `combinations` must not be supported: vector for DoS attack
- same NOT for `repeat` etc.; `recurse` should be carefully thought if DoS
- but `walk` looks more sane in thius regard
- `tojson` and `fromjson`: probably also need `tocbor` and `fromcbor` for
  between encoding and internal representation in variables; may be tags #6.63
  and 24 be done via this
- date/time funcs looks like better it be packages/namespaces/modules
- Alternative operator: // looks like same Perl's
- try/catch/break already similar to Tcl
- `.resources[] as {$id, $kind, ...` reminds `lset`
- `first`, `last`, `nth` (especially with expr) look like idea for
  Template::Toolkit's methods on interator in [% FOREACH %]
- "Assignment works a little differently in jq than in most programming
  languages. jq doesn't distinguish between references to and copies of
  something [...]  If you're used to programming in languages like Python,
  Java, Ruby, JavaScript, etc. then you can think of it as though jq does
  a full deep copy of every object before it does the assignment [...] This
  means that it's impossible to build circular values in jq (such as an array
  whose first element is itself). This is quite intentional, and ensures that
  anything a jq program can produce can be represented in JSON." -- but we
  already have tags in CBOR for references, even circular...
- "Note that the LHS of assignment operators refers to a value in `.`. Thus
  `$var.foo = 1` won't work as expected (`$var.foo` is not a valid or useful
  path expression in .); use `$var | .foo = 1` instead." -- here looks like
  distinction `$name::space::varname->{path}->{in}->{var}->[1]` so our scalar
  get '$' should be rethought a little?..
  - 06.03.25 17:09 so for '$' let's go variable tree "unified CBOR document"
    way: beginning of path always about which variable to select, all other
    members are just ->{strings}->{and_indexes}->[1] no matter these are
    variables or their contents - so in fact we need just to specify "root"
    variable, be it local or absolute. So let beginning element of path be:
    * tstr: name of variable in local CallFrame
    * uint >= 1: as $1, $2... in shell, args of this proc; regexp capture groups
    * nint, tstr: local variable of CallFrame immediately parent for -1,
      grandparent for -2, etc.
    * 0, tstr: name of global variable == top (uplevel #0) CallFrame
    * TBD bstr is CBOR Sequence of tstr's: namespace variable. Most
      questionable if we want modules to store proc's in namespaces also...
      - 17:35 may be tstr and a Perl rule that namespaces contain
        alphanumeric, all other symbols go global (main) ?
      - 17:50 Tcl has:
        | namespace path ?namespaceList?
        | Returns the command resolution path of the current namespace. If
        | `namespaceList` is specified as a list of named namespaces, the
        | current namespace's command resolution path is set to those
        | namespaces and returns the empty list. The default command resolution
        | path is always empty.
        | [...]
        | Command names are always resolved by looking in the current namespace
        | first. If not found there, they are searched for in every namespace
        | on the current namespace's command path (which is empty by default).
        | If not found there, command names are looked up in the global
        | namespace (or, failing that, are processed by the appropriate
        | namespace unknown handler.)
        so this allows somewhat like inheritance (in fact it is @ISA)
      - 18:09 use '/' as separator because easier to parse / compact? as root
        is empty ($::varname) tell this is like MQTT path... yes, and that
        would be natural method call in MQTT-based RPC!
        - 07.03 21:00 why parse? plain [cbor, array] is not 10([cmd, array]])
          so is not interpreted - thus make it natural (and already parsed)
          namespace delimiter (and MQTT may live in namespace and/or have it's
          slashes without collisions with our languages); moreover, we may
          have also name CBOR-Based Assembler/Parsed Tree and specific
          compression tasks are just a set of commands: "package require CBAR"
    - 10.03.25 19:00 don't encode CallFrame sequence into variable access,
      define it's just as "local scope" (use e.g. "upvar" command if needed)
      by default being the CallFrame - because it allows future extensions like
      lexical scopes; also note that we are not programming language per se but
      Intermediate Representation more closer to high-level assembler, so it
      may be e.g. 10(['lexical-scope', ['x'], 'foreach','x',[use '$','x'...]])
      and there is no problem in verbosity here - it is not expected neither
      in every compressed message (live somewhere by 'ld') nor in non-CBAR
      programming as those will be generated from some more human-friendly
      and compact DSL. So:
      * tstr: name of variable in local or some outer scope: CallFrame in basic
	version or modified according to rules of some extension command
      * uint = 0: TBD
      * uint > 0: temporary variables between dictionary setup in constrained
	implementations or some other temporary variables in *any* context,
	e.g. Regexp capture groups or Shell's set -- $@/$*
	- 15.03.25 23:59 but what with dictionary numbers -e.g. first arg to
	  splice() ?
	  - 01:00 scrolled text/notes, it wasn't worked through yet: at first
	    splice() was acting in variables, of which all were disposed and
	    variable 0 became the sole dictionary, then from Jan 07 idea of
	    Alternatives Tags was for encoding and splice() change wasn't
	    decided yet (so M. Lenders confused variables with dictionaries);
	    then idea flow went to Stack Machine in February (and then to
	    prefix notation) again without details of accessing in code; and
	    'get-atom' ('a') also was just separated from '$' without thinking
	    of which dictionary is current... in fact, it was not quite needed
	    until 27 Feb support for string variable names - variable tree in
	    from of arrays-only was supposed for access to everything (just
	    assigning exact numbers in it was postponed). This is also tightly
	    coupled with 'process-cbor' inner works: see 26.02.25 12:56 (and
	    thread below) for separate (from CallFrame) dictionaries stack by
	    'process-cbor' - however, now I want uniform variable handling in
	    functions like splice() so there is nothing special in data model
	    about dictionaries at all for usability of language in non-CBAR
	    applications - and even in CBAR not every 'process-cbor' should be
	    coupled with DictFrame pushing (see e.g. 15.03.25 03:35 for
	    complex "$subdocument" variable assignment)
	    - 01:35 as 'process-cbor' is what handles #6.10(#6.121(element)) as
	      expanding/replacing them to code calls like 10(['$', ...]), this
	      means that CBAR dictionaries for compression, central there,
	      must be just one particular-case use of 'process-cbor' in CBAPT
	      - 18.03.25 Perl makes $1, $2... read-only and dynamically scoped,
		set only by regexp operations; Shell has same scoping and R/O
		and additionally sets them in every function or by "set"
		builtin command - so we also should have them R/O and set only
		explicitly. But while having Alternatives Tags for selecting
		from several dictionaries is useful and must be supported, why
		do we have to localize *all* 128 dicts in DictFrame? Do
		document composability really need it *this way*? 05-06.02.25
		quickly changed from register window to (nint) 128*level+dict
		but at 10.03.25 I considered direct references to CallFrame in
		variables to be bad for extensibility (baking too early), so
		may be same thing true for dictionaries? OK, for dictionaries
		it makes more sense to have access to upper layers, e.g. for
		inheritance - we're doing templating, after all - but what if
		composability is doable with only one dictionary redefined?
		And other uint dict numbers be shifted into positive direction,
		or even be non-stack but global? It's just simple(0)..simple(6)
		what looks beautiful for direct assignments to dict 0..6
		- 19.03.25 02:45 declare like in BPF_PROLOG? which will be
		  implicitly 1 by simple(0) if no other setup cmds
		- 19.03.25 04:00 here's strong argument: it's expensive for
		  constrained implementations to keep 128 dicts *per frame*
		  so must be explicit dictionary push only
      * [+tstr]: namespace variable
- 07.03.25 16:30 to support compiling to machine code, variables in [proc]'s
  must provide for (optional if non-compiled but dynamic) typing, for this
  Tag 21607(uint) [https://cbor.is4.site/cbor-tag] may be used, e.g. tag
  69(bstr) means array of uint16 (little endian) - but these are incomplete,
  yet need to define here Major Type and Additional Info for e.g. array/memory
  size. Also need a command or yet another [proc] argument to declare all used
  variables in CallFrame, again with such types: all in one place, higher-level
  languages may define more sugar throughout functions; and also think for
  some support of closures (Jim Tcl?)
  - 12.03.25 16:15 such compiling, and not only compiling, but even e.g.
    firewall rules (in non-compiled form) need some "goto but_only_forward",
    or "skipto" (in firewall case) - seems that "break" and "continue" Tcl
    codes are not enough here, may be really "skip" and e.g. represent as
    foreach on some statements collection?
    - 16:40 make all that codes also accept string in addition to int for
      going to named label, or that label-named block of loops? see perlsyn
      for LABEL: while (...) {...}
  - 18.03.25 to avoid too many arguments to [proc], map may be used:
    "-static", "-doc" etc. keys; and think of somehow doing this generally
    instead of Tcl's -options?

13.03.25 https://skarnet.org/software/execline/dieshdiedie.html
will read nice and -10 from the argv, change the process' nice value, then exec into the command echo blah. This is called chain loading by some people, and Bernstein chaining by others.

15.03.25 Lisp
You can also <i>splice</i> an evaluated value into the resulting list, using the special marker ‘,@’.

 progn evaluates forms, in the order in which they are given.
The values of each form but the last are discarded.

let and let* create new variable bindings and execute a series of forms that use these bindings


19.03.25
The x87 registers form an eight-level deep non-strict stack structure ranging from ST(0) to ST(7) with registers that can be directly accessed by either operand, using an offset relative to the top, as well as pushed and popped. (This scheme may be compared to how a stack frame may be both pushed/popped and indexed.)

There are instructions to push, calculate, and pop values on top of this stack; unary operations (FSQRT, FPTAN etc.) then implicitly address the topmost ST(0), while binary operations (FADD, FMUL, FCOM, etc.) implicitly address ST(0) and ST(1). The non-strict stack model also allows binary operations to use ST(0) together with a direct memory operand or with an explicitly specified stack register, ST(x), in a role similar to a traditional accumulator (a combined destination and left operand). This can also be reversed on an instruction-by-instruction basis with ST(0) as the unmodified operand and ST(x) as the destination. Furthermore, the contents in ST(0) can be exchanged with another stack register using an instruction called FXCH ST(x).

These properties make the x87 stack usable as seven freely addressable registers plus a dedicated accumulator (or as seven independent accumulators).


security considerations - escaping in templates (like HTML)

21.03.25 jinja2 templates:
loop.index & loop.index0 and methods like .previtem may be helpful for compression
- "Unlike in Python, it’s not possible to break or continue in a loop" - huh,
  we can
- "The advantage is that the special loop variable will count correctly;
  thus not counting the users not iterated over."
  - we have multiple lists to iterate on, one of which may be such counter
    TBD think about generator coroutines to help with large range()
- TBD loop recursive - is it needed, or map/lambda is better?
-


29.03.25 Original from
https://github.com/anr-bmbf-pivot/draft-lenders-dns-cbor/pull/7/files : 
==8<==
Take the following CBOR object _o_ (note that this is intentionally not legal "application/dns+cbor" to illustrate generality).

~~~ edn
[
  "www", "example", "org",
  ["svc", "www", "example", "org"],
  "org", "example", "org", 42,
  "svc", "www", "example", "org", 42
]
~~~
{: #fig:name-compression-example-unpacked title="Unpacked example for implicit text string suffix sequence compression."}

This would generate the following virtual table _V_.

~~~ edn
[
    ["www", "example", "org"],
    ["example", "org"],
    ["org"],
    ["svc", simple(0)],
    ["org", "example", "org"]
]
~~~
{: #fig:name-compression-example-table title="Implicit table of shared items for the example."}

Note that the sequence "org", "example", "org" is added at index 4 with leading "org", instead of referencing index 2 + index 1 (`simple(2), simple(1)`), as it is its own distinct suffix sequence.

The packed representation of _o_ would thus be:

~~~ edn
TBD28259(
  [
    ["www", "example", "org"],
    ["svc", simple(0)],
    "org", simple(1), 42,
    simple(3), 42
  ]
)
~~~
{: #fig:name-compression-example-packed title="The packed representation of the example."}

Note, with "application/dns+cbor;packed=0" the surrounding TBD28259 can be elided (even though the content would not be parsable as application/dns+cbor).

With, e.g., table setup tag 113, further packing can be achieved via nesting table packing.

~~~ edn
TBD113(
  TBD28259(
    [
      ["org", 42],
      [
        ["www", "example", simple(5)],
        ["svc", simple(0)],
        simple(5), simple(1), simple(6),
        simple(3), simple(6)
      ]
    ]
  )
)
~~~
{: #fig:name-compression-example-packed-113 title="The packed representation of the example with additional table setup."}

Note, how the previous references in {{fig:name-compression-example-packed}} do not changed, as the table `["org", 42]` is appended.
==8<==


Now let's create CBAPT function for it


10([
  'proc', 'name-comp', ['domain-list'], /procedure with single argument/
  [ /procedure body/
   'set', 'atom-list', [], ';'         /initialize empty array local var/
   'foreach', 'fqdn', '@','domain-list',    /loop variable called "fqdn"/
   [ /outer foreach body - on full domains from 'domain-list' array/
      'set', 'accum', '', ';'                 /empty string to accumulator/
      'foreach', 'label',                     /loop variable called "label"/
           10(['lreverse', '@', 'fqdn']),     /on reversed label list/
      [ /inner foreach body/
        'if', ['is_cbor_uint', '$', 'label'], /reference instead of label?/
	[ /if "then" body/
	  'set', 'label', '$',                /to value of CBOR Pointer /
	         ['atom-list',                /in 'atom-list' var: array/
		              '$', 'label']   /index in 'label' in this case/
	], ';'
        'set', 'accum',              /set accum to string concatenation/
	       10(['strconcat',      /of value of "label" variable converted/
	            10(['to_tstr', '$', 'label']),  /to CBOR Major Type 3 /
		    '$', 'accum'     /and previous value of "accum" var  /
	          ]),
        ';',                            /command separator (end of 'set') /
	/now prepend value of "accum" variable to 'atom-list' array/
	'unshift', 'atom-list', '$', 'accum' /TBD is 'linsert' more readable?/
      ],
   ], ';'
   /*** NOTE TODO this lacks error-checking and suppression ***/
   /*** of repeated entries - but you get the core idea     ***/
   'return', 10(['@', 'atom-list'])           /make list from array/
  ], /end of procedure body/
  ';'
  'parse-alias', 'nc', 1, 'name-comp' /for shortened spliced use/
])

Now, assume procedure above is imported by tag or media type, so it can be
used in following way:

    10([simple(0),
        "foo",          /Atom 0/
	'nc',           /call function and substitute it's return values/
	[               /this will create 7 atoms/
          ["svc", "www", "example", "org"],
          ["datatracker", "ietf", 3]        /atom-list[3] is "org"/
        ],
	"bar",          /Atom 8/
        "baz",          /Atom 9/
        h' /CBAR rump/
	  8F            /outer array/
	  3D            /Atom 2: CwwwGexampleCorg/
	  84            /inner array/
          1E            /Atom 1: CsvcCwwwGexampleCorg /
	  5E            /Atom 5: KdatatrackerDietfCorg /
	  18 2a         /42/
          1E            /Atom 1: CsvcCwwwGexampleCorg /
	  1D            /Atom 0: Cfoo /
	  9C            /Atom 8: Cbar /
	  9D            /Atom 9: Cbaz /
  	'
    ])

[
  "www", "example", "org",                               
  ["svc", "www", "example", "org"],
  "datatracker", "ietf", "org", 42,
  "svc", "www", "example", "org",
  "foo", "bar", "baz"
]
00000000  8f 43 77 77 77 47 65 78  61 6d 70 6c 65 43 6f 72  |.CwwwGexampleCor|
00000010  67 84 43 73 76 63 43 77  77 77 47 65 78 61 6d 70  |g.CsvcCwwwGexamp|
00000020  6c 65 43 6f 72 67 4b 64  61 74 61 74 72 61 63 6b  |leCorgKdatatrack|
00000030  65 72 44 69 65 74 66 43  6f 72 67 18 2a 43 73 76  |erDietfCorg.*Csv|
00000040  63 43 77 77 77 47 65 78  61 6d 70 6c 65 43 6f 72  |cCwwwGexampleCor|
00000050  67 43 66 6f 6f 43 62 61  72 43 62 61 7a           |gCfooCbarCbaz|


TBD 07.04.25 22:00 delta encoding: is it worth in VarElem for some to be delta
to last output atom number? requires 3 ranges: absolute, +N and -N, how many
for each? and again FC do not need neither character names nor deltas
- ^^vv may be use 7C 0n for deltas like FD 0n is array and not atom?
TBD 07.04.25 23:00 need to think more about atom typing, it's already have
slightly different handling of #6.63 in atom setup and in processed CBOR, and
in MyLED example we always use 7C xx conversion from bstr to tstr - if change
it to single-byte IN_CBOR atoms, then 535 byte example could be 40+ bytes less!


TODO 21.04.25 for just returning arguments use ['id', arg1, arg2, ...]:
> Similarly, the function
>    id ⁡ ( x ) = x {\displaystyle \operatorname {id} (x)=x}
> can be rewritten in anonymous form as
>    x ↦ x {\displaystyle x\mapsto x}
> where the input is simply mapped to itself.[d]


TBD 01.05.25 22:30 The simple(0)..simple(6) and 15.03.25 03:35, 15.03.25 23:59
threads: let's define simple(D) function pseudocode as:
   if dicts[D] is not null:
      push D+1 null's to beginning of dicts[] so that
      dicts[0] moves to dicts[D+1], etc.
   dicts[D] = process arguments expanding them by atoms with current
              dictionary set to D
   set digit variables (for 10(0), 10(1) etc.) if has rump TBD for >0 also?
   process rump in DWIM fashion
so after [simple(3), "Lisp", "Perl", "Python", "Ruby", "Tcl"] it then could be
used [simple(0), "foo", "bar", "baz"] and language names remain at dicts[3]
while dicts[1] and dicts[2] are empty, so simple(1) and simple(2) can be
issued in any order, or it can even be 10(["set-dict", 2, 100]) for doing
dicts[2]=dicts[100] to access distant dictionary one byte less; of course
dicts[] is stack variable local to 'process-cbor' (with references to actual
refcounted arrays) so such ["set-dict"] will be canceled on return just as
other "pushed" dictionaries



TODO

https://github.com/nuclight/musctp/blob/main/cbar.txt

=== 20.01.25 commentary on IETF CBOR Interim meetings:

https://youtu.be/ktfH2jfU7ik?t=1822 : tag ranges on this slide (about "idiom")
are occupying just a small fraction of corresponding range X+Y range - but
cbor-packed differs radically

37:00 little simulation that assumes that tables are used according to Zip's law
-- not a real data!

44:26 private tags -- what about namespace?

45:35 in Json LD you know that uh you are processing a CURIE depending on where
-- so CBAR tries to do with multiple dictionaries for this

well, I'm not a PhD talked about, I'm just same level with less tags

47:20 and know what that is doing because the pieces might be interfering with each
47:25 other um there actually proposals right now for fixing the the
47:31 original uh sharing uh tags that that have been defined for Pearl uh to to
47:38 make this uh a little bit less vulnerable to composability
47:43 uh
47:52 problems is how is how is packed on not endangering that composability in the
47:59 same way because a reference is not supposed to
48:06 go outside of the the table set of tag that
-- what is meant here?

1:00:33 that that's really precious it's too bad that we cannot use the additional the free additional information space and
1:00:40 I'm open to wild ideas there but the the compatibility issue
-- CBAR solves it by wrapping in bstr
