footer:CBOR 2025-04-30 • Vadim Goncharov <vadimnuclight@gmail.com> • bad MD-to-PDF formatting by deckset.com
slidenumbers: true
theme: work, 1
autoscale: true
build-lists: true
slide-dividers: #
# CBAR/CBAPT vs cbor-packed on shortest possible example

Unpacked 48-byte CBOR (note "bar" vs "br" after 2nd "foo"):

```js
   ["foobarbaz1", "foobrbaz2foobarquux", "foo", "bar", 'bar', "baz"]

0000  86 6a 66 6f 6f 62 61 72  62 61 7a 31 73 66 6f 6f  |.jfoobarbaz1sfoo|
0010  62 72 62 61 7a 32 66 6f  6f 62 61 72 71 75 75 78  |brbaz2foobarquux|
0020  63 66 6f 6f 63 62 61 72  43 62 61 72 63 62 61 7a  |cfoocbarCbarcbaz|
```

cbor-packed - 30 bytes rump:

```js
  1113([["foo", "bar", 'bar', "baz"],          /* shared   */
        ["foobar", h'666f6f62'],               /* argument */
        [224("baz1"), 225("rbaz2foobarquux"),  /* rump */
         simple(0), simple(1), simple(2), simple(3)]
  ])

0000  86 d8 e0 64 62 61 7a 31  d8 e1 6f 72 62 61 7a 32  |...dbaz1..orbaz2|
0010  66 6f 6f 62 61 72 71 75  75 78 e0 e1 e2 e3        |foobarquux....|
```

CBAR - 24 bytes rump, like `24(bstr)` / COSE:

```js
  10([simple(0), "foo", "bar", "baz",
    h'86 6A C0 C1 F5 31  73 C0 62 72 C1 32  C0 C1 71757578 1D 1E 5C 01 3D'
/*    [  "  |  |  |  '1'  " |   'br'  | '2' |  |   'quux'  |  |  b.cvt. |
            |  |  `b.Atom 3 `b.Atom 0 |     |  `b.Atom 1   |  |  Atom 1 |
            |  `b.Atom 1              |     `b.Atom 2      |  c.Atom 1  |
            `b.Atom 0                 `b.Atom 1    c.Atom 0'    c.Atom 2'
*/])
```

---

# On cbor-packed "radical" - criteria

The problem with cbor-packed goals are that priority of compression ratio and priority of implementation simplicity or priority of less memory allocations in decoder - are not given clear weights (in contrast to e.g. CBOR itself when it compares itself with competing formats like MsgPack).
It clearly *smells* that "radical" approach, in form of "all zero", is **too** suppressing compression effectiveness - but where to draw the boundary? Without some numbers we don't know how to weight it.

**Of course the problem is a consequence of used method:**

If the only possible way to do semantic compression of CBOR without allocating temporary buffer by decoder is *to do it fully expressible in CBOR itself* - that is, the way cbor-packed is built, - then I'd vote to allocating **much more** resources then original draft demands - say, 116 tags in 1+1 range.

## But it is not the only way.

---

# Thesis: any packing scheme works better built into decoder

For example, look at COSE / anything using Tag 24: it has CBOR wrapped into `bstr` from which it could be decoded in-place if decoder supports this - it will just apply the same CBOR decoding process to that `bstr`.

CBAR/CBAPT offers same approach, utilizing slightly modified CBOR inside such `bstr`, presenting unpacked (modulo string chunks API) to application.

This works better (for application-writers) even for cbor-packed.

---

# Attempts to save cbor-packed

## Tag composability

Replace

```
   6([N, rump])
```

to

```
   6(N(rump))
```

where **N** does NOT have it's usual meaning but is solely an argument for Tag 6.
See <https://mailarchive.ietf.org/arch/msg/cbor/iPHSDPKUTokMTRokoKZMlbiowz4/>

This allows to save one byte - of array start. Problem: only positive values.

For decoder implemented according to Thesis, no compatibility problems at all.

---

# Attempts to save cbor-packed

Again, for decoder built according to Thesis...

## Radical: Use reserved values

Current CBOR's STD forbids simple values less than 32 in two-byte representation. This may be extended to use `0xF8 0b000xxxxx` for whatever packing wants.

## Not so radical: use simples 24-31

---

# On resources / standards conflicts: tags

> "Standards are good: there are so many to choose from"

Can we allow mutiple standards to co-exist as "Solomon solution"? E.g. let it be both CDE and dCBOR - and "let's the market decide".

To do this, standards must not conflict on resource usage. In case of cbor-packed, that means:

1. Tag over-usage - not reusable any other in CBOR ecosystem:

   - solved "good enough" by reducing usage via A, B, C variables

---

# On resources / standards conflicts: simple values

2. Simple values in 1+0 range - not solved:

   - how can application or other standard's usage to not clash with cbor-packed?

   ```js
    10([simple(0), "foo", "bar", "baz", 
       113([["rgbValue", "rgbValueRed", "rgbValueGreen",]    /* WAT?  */
           [/* cbor-packed rump*/
                simple(0), simple(1), simple(2), 10(0),      /* YEAH! */
                simple(0), simple(1), simple(2), 10(1),
                simple(0), simple(1), simple(2), 10(2)
           ]
       ])
      /* BUT THE OPPOSITE IS NOT POSSIBLE */ 
    ])
   ```

## ...Register simples with requirement being confined inside tag?

---

# Conclusion

```
    allowed_to_register = round_down_to(some-multiple-of-2,
                                        sqrt(free-in-this-range))
```

But it would be classic "design by committee" problem: bad for every side.

If we are going to accept some non-zero number, let's do it top-down: e.g. `simple(17)..simple(20)` to leave a contiguous block for other applications.

## However, I'd prefer to offer to Working Group to defer decision process for at least several interims, until a (full) interim dedicated to cbor-packed alternatives is done.

